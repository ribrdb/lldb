<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url('https://themes.googleusercontent.com/fonts/css?kit=lhDjYqiy3mZ0x6ROQEUoUw');ul.lst-kix_2gjuodkcyzyk-2{list-style-type:none}.lst-kix_2gjuodkcyzyk-7>li:before{content:"\0025cb  "}ul.lst-kix_2gjuodkcyzyk-1{list-style-type:none}ul.lst-kix_2gjuodkcyzyk-4{list-style-type:none}.lst-kix_2gjuodkcyzyk-6>li:before{content:"\0025cf  "}.lst-kix_2gjuodkcyzyk-8>li:before{content:"\0025a0  "}ul.lst-kix_2gjuodkcyzyk-3{list-style-type:none}.lst-kix_2gjuodkcyzyk-5>li:before{content:"\0025a0  "}ul.lst-kix_2gjuodkcyzyk-6{list-style-type:none}ul.lst-kix_2gjuodkcyzyk-5{list-style-type:none}ul.lst-kix_2gjuodkcyzyk-8{list-style-type:none}ul.lst-kix_2gjuodkcyzyk-7{list-style-type:none}ul.lst-kix_kok7olkdgoid-8{list-style-type:none}ul.lst-kix_kok7olkdgoid-2{list-style-type:none}ul.lst-kix_kok7olkdgoid-3{list-style-type:none}.lst-kix_2gjuodkcyzyk-0>li:before{content:"\0025cf  "}ul.lst-kix_kok7olkdgoid-0{list-style-type:none}ul.lst-kix_kok7olkdgoid-1{list-style-type:none}.lst-kix_2gjuodkcyzyk-1>li:before{content:"\0025cb  "}ul.lst-kix_kok7olkdgoid-6{list-style-type:none}ul.lst-kix_kok7olkdgoid-7{list-style-type:none}ul.lst-kix_kok7olkdgoid-4{list-style-type:none}ul.lst-kix_kok7olkdgoid-5{list-style-type:none}.lst-kix_2gjuodkcyzyk-3>li:before{content:"\0025cf  "}.lst-kix_2gjuodkcyzyk-2>li:before{content:"\0025a0  "}.lst-kix_2gjuodkcyzyk-4>li:before{content:"\0025cb  "}ul.lst-kix_9h0dn3k8g6gu-8{list-style-type:none}ul.lst-kix_9h0dn3k8g6gu-7{list-style-type:none}ul.lst-kix_9h0dn3k8g6gu-0{list-style-type:none}ul.lst-kix_4kmb8s9kgjmz-8{list-style-type:none}ul.lst-kix_9h0dn3k8g6gu-2{list-style-type:none}ul.lst-kix_9h0dn3k8g6gu-1{list-style-type:none}ul.lst-kix_9h0dn3k8g6gu-4{list-style-type:none}ul.lst-kix_9h0dn3k8g6gu-3{list-style-type:none}ul.lst-kix_9h0dn3k8g6gu-6{list-style-type:none}ul.lst-kix_9h0dn3k8g6gu-5{list-style-type:none}ul.lst-kix_4kmb8s9kgjmz-1{list-style-type:none}ul.lst-kix_4kmb8s9kgjmz-0{list-style-type:none}ul.lst-kix_4kmb8s9kgjmz-3{list-style-type:none}ul.lst-kix_4kmb8s9kgjmz-2{list-style-type:none}ul.lst-kix_4kmb8s9kgjmz-5{list-style-type:none}ul.lst-kix_4kmb8s9kgjmz-4{list-style-type:none}ul.lst-kix_4kmb8s9kgjmz-7{list-style-type:none}ul.lst-kix_4kmb8s9kgjmz-6{list-style-type:none}.lst-kix_9h0dn3k8g6gu-0>li:before{content:"\0025cf  "}.lst-kix_kok7olkdgoid-7>li:before{content:"\0025cb  "}.lst-kix_kok7olkdgoid-8>li:before{content:"\0025a0  "}.lst-kix_9h0dn3k8g6gu-1>li:before{content:"\0025cb  "}.lst-kix_9h0dn3k8g6gu-4>li:before{content:"\0025cb  "}.lst-kix_9h0dn3k8g6gu-2>li:before{content:"\0025a0  "}.lst-kix_9h0dn3k8g6gu-3>li:before{content:"\0025cf  "}.lst-kix_9h0dn3k8g6gu-8>li:before{content:"\0025a0  "}.lst-kix_6908695am9jc-0>li:before{content:"\0025cf  "}.lst-kix_ocz9n0luljdt-3>li:before{content:"\0025cf  "}.lst-kix_9h0dn3k8g6gu-5>li:before{content:"\0025a0  "}.lst-kix_ocz9n0luljdt-1>li:before{content:"\0025cb  "}.lst-kix_ocz9n0luljdt-2>li:before{content:"\0025a0  "}.lst-kix_4kmb8s9kgjmz-7>li:before{content:"\0025cb  "}.lst-kix_9h0dn3k8g6gu-6>li:before{content:"\0025cf  "}.lst-kix_ocz9n0luljdt-0>li:before{content:"\0025cf  "}.lst-kix_4kmb8s9kgjmz-8>li:before{content:"\0025a0  "}.lst-kix_9h0dn3k8g6gu-7>li:before{content:"\0025cb  "}.lst-kix_4kmb8s9kgjmz-6>li:before{content:"\0025cf  "}.lst-kix_4kmb8s9kgjmz-5>li:before{content:"\0025a0  "}.lst-kix_ocz9n0luljdt-4>li:before{content:"\0025cb  "}.lst-kix_4kmb8s9kgjmz-3>li:before{content:"\0025cf  "}.lst-kix_ocz9n0luljdt-5>li:before{content:"\0025a0  "}.lst-kix_ocz9n0luljdt-6>li:before{content:"\0025cf  "}.lst-kix_4kmb8s9kgjmz-2>li:before{content:"\0025a0  "}.lst-kix_4kmb8s9kgjmz-4>li:before{content:"\0025cb  "}.lst-kix_ocz9n0luljdt-7>li:before{content:"\0025cb  "}.lst-kix_4kmb8s9kgjmz-0>li:before{content:"\0025cf  "}.lst-kix_4kmb8s9kgjmz-1>li:before{content:"\0025cb  "}.lst-kix_ocz9n0luljdt-8>li:before{content:"\0025a0  "}ul.lst-kix_2gjuodkcyzyk-0{list-style-type:none}ul.lst-kix_ocz9n0luljdt-7{list-style-type:none}ul.lst-kix_ocz9n0luljdt-8{list-style-type:none}ul.lst-kix_ocz9n0luljdt-5{list-style-type:none}ul.lst-kix_ocz9n0luljdt-6{list-style-type:none}ul.lst-kix_6908695am9jc-7{list-style-type:none}ul.lst-kix_6908695am9jc-6{list-style-type:none}ul.lst-kix_6908695am9jc-8{list-style-type:none}ul.lst-kix_6908695am9jc-3{list-style-type:none}ul.lst-kix_6908695am9jc-2{list-style-type:none}ul.lst-kix_6908695am9jc-5{list-style-type:none}ul.lst-kix_6908695am9jc-4{list-style-type:none}ul.lst-kix_ocz9n0luljdt-3{list-style-type:none}ul.lst-kix_ocz9n0luljdt-4{list-style-type:none}ul.lst-kix_ocz9n0luljdt-1{list-style-type:none}ul.lst-kix_ocz9n0luljdt-2{list-style-type:none}ul.lst-kix_ocz9n0luljdt-0{list-style-type:none}.lst-kix_6908695am9jc-8>li:before{content:"\0025a0  "}.lst-kix_6908695am9jc-6>li:before{content:"\0025cf  "}.lst-kix_6908695am9jc-7>li:before{content:"\0025cb  "}ul.lst-kix_6908695am9jc-1{list-style-type:none}ul.lst-kix_6908695am9jc-0{list-style-type:none}.lst-kix_6908695am9jc-1>li:before{content:"\0025cb  "}.lst-kix_6908695am9jc-2>li:before{content:"\0025a0  "}.lst-kix_6908695am9jc-3>li:before{content:"\0025cf  "}.lst-kix_6908695am9jc-4>li:before{content:"\0025cb  "}.lst-kix_6908695am9jc-5>li:before{content:"\0025a0  "}.lst-kix_kok7olkdgoid-6>li:before{content:"\0025cf  "}.lst-kix_kok7olkdgoid-4>li:before{content:"\0025cb  "}.lst-kix_kok7olkdgoid-5>li:before{content:"\0025a0  "}.lst-kix_kok7olkdgoid-2>li:before{content:"\0025a0  "}.lst-kix_kok7olkdgoid-3>li:before{content:"\0025cf  "}.lst-kix_kok7olkdgoid-0>li:before{content:"\0025cf  "}.lst-kix_kok7olkdgoid-1>li:before{content:"\0025cb  "}ol{margin:0;padding:0}.c7{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:468pt;border-top-color:#000000;border-bottom-style:solid}.c1{padding-top:0pt;padding-bottom:0pt;line-height:1.0;orphans:2;widows:2;text-align:left;direction:ltr}.c5{padding-top:15pt;padding-bottom:15pt;line-height:1.3;orphans:2;widows:2;direction:ltr;margin-right:15pt}.c2{color:#000000;font-weight:normal;text-decoration:none;vertical-align:baseline;font-size:11pt;font-style:normal}.c12{background-color:#ffffff;color:#222222;font-weight:normal;text-decoration:none;vertical-align:baseline;font-style:normal}.c20{padding-top:14pt;padding-bottom:4pt;page-break-after:avoid;orphans:2;widows:2;direction:ltr}.c9{padding-top:0pt;padding-bottom:0pt;line-height:1.0;text-align:left;direction:ltr}.c15{margin-left:36pt;orphans:2;widows:2;padding-left:0pt;direction:ltr}.c48{padding-top:30pt;padding-bottom:30pt;line-height:1.4;margin-right:30pt}.c35{padding-top:15pt;padding-bottom:15pt;line-height:1.4;margin-right:15pt}.c11{background-color:#efefef;font-size:10.5pt;font-family:"Verdana";color:#222222}.c27{color:#000000;font-weight:bold;vertical-align:baseline;font-style:normal}.c45{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c34{padding-top:16pt;padding-bottom:4pt;page-break-after:avoid}.c30{padding-top:18pt;padding-bottom:6pt;page-break-after:avoid}.c22{padding-top:15pt;padding-bottom:15pt;line-height:1.0}.c21{orphans:2;widows:2;direction:ltr}.c33{border-collapse:collapse;margin-right:auto}.c29{margin-left:51pt;border-collapse:collapse;margin-right:auto}.c16{background-color:#ffffff;font-size:8pt;color:#222222}.c40{font-size:14pt;color:#434343;font-weight:normal}.c18{background-color:#ffffff;color:#222222}.c32{font-weight:normal;vertical-align:baseline}.c13{color:inherit;text-decoration:inherit}.c6{color:#1155cc;text-decoration:underline}.c28{font-size:16pt;font-weight:normal}.c36{border-collapse:collapse;margin-right:auto}.c24{padding:0;margin:0}.c0{font-family:"Consolas"}.c46{font-style:normal}.c38{margin-left:-18pt}.c26{margin-left:15pt}.c3{font-family:"Trebuchet MS"}.c8{font-style:italic}.c50{color:#375eab}.c51{background-color:#fff2cc}.c31{margin-left:54pt}.c49{background-color:#ffffff}.c25{height:11pt}.c39{font-family:"Verdana"}.c19{font-size:8pt}.c10{font-size:11pt}.c17{text-decoration:none}.c23{margin-left:36pt}.c47{margin-left:-25.5pt}.c37{margin-left:-2.2pt}.c14{font-size:12pt}.c41{font-weight:bold}.c4{height:0pt}.c43{color:#000000}.c44{page-break-after:avoid}.c52{font-size:21pt}.c42{margin-left:18pt}.title{padding-top:0pt;color:#000000;font-size:21pt;padding-bottom:0pt;font-family:"Trebuchet MS";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:13pt;padding-bottom:10pt;font-family:"Trebuchet MS";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:10pt;color:#000000;font-size:16pt;padding-bottom:0pt;font-family:"Trebuchet MS";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:10pt;color:#000000;font-weight:bold;font-size:13pt;padding-bottom:0pt;font-family:"Trebuchet MS";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:8pt;color:#666666;font-weight:bold;font-size:12pt;padding-bottom:0pt;font-family:"Trebuchet MS";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:8pt;color:#666666;text-decoration:underline;font-size:11pt;padding-bottom:0pt;font-family:"Trebuchet MS";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:8pt;color:#666666;font-size:11pt;padding-bottom:0pt;font-family:"Trebuchet MS";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:8pt;color:#666666;font-size:11pt;padding-bottom:0pt;font-family:"Trebuchet MS";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c45"><p class="c21 c22 title"><a name="h.5v6crjt8m83b"></a><span class="c49">Debugging Go Code with LLDB</span></p><p class="c21 c44 subtitle"><a name="h.3v077nbk0ug7"></a><span class="c10">Updated Sept 28, 2015</span></p><p class="c21 c25"><span class="c3"></span></p><p class="c21 c42"><span class="c6 c3"><a class="c13" href="#h.gsf36tewhzbh">Introduction</a></span></p><p class="c21 c23"><span class="c6 c3"><a class="c13" href="#h.1utdmm7zjmva">Getting lldb</a></span></p><p class="c21 c23"><span class="c6 c3"><a class="c13" href="#h.xlc2v7pv9qq1">Common Operations</a></span></p><p class="c21 c23"><span class="c6 c3"><a class="c13" href="#h.ysbfyj1xcm8z">Go Extensions</a></span></p><p class="c21 c31"><span class="c6 c3"><a class="c13" href="#h.t0hx7awbcpi">Expression parsing</a></span></p><p class="c21 c31"><span class="c6 c3"><a class="c13" href="#h.hdz0ga20kehk">Interfaces</a></span></p><p class="c21 c31"><span class="c6 c3"><a class="c13" href="#h.e6oyh7whpt27">Data Formatters</a></span></p><p class="c21 c31"><span class="c3 c6"><a class="c13" href="#h.j0x7islcroa0">Goroutines</a></span></p><p class="c21 c23"><span class="c6 c3"><a class="c13" href="#h.xma35v7inmhr">Known Issues</a></span></p><p class="c21 c42"><span class="c6 c3"><a class="c13" href="#h.dne486jm8zom">Tutorial</a></span></p><p class="c21 c23"><span class="c6 c3"><a class="c13" href="#h.2nwggnckmiwr">Getting Started</a></span></p><p class="c21 c23"><span class="c6 c3"><a class="c13" href="#h.ri718mqxww7e">Setting breakpoints</a></span></p><p class="c21 c23"><span class="c6 c3"><a class="c13" href="#h.l4wnfs5n0ijf">Inspecting the source</a></span></p><p class="c21 c23"><span class="c6 c3"><a class="c13" href="#h.bfkmoyw1xf9d">Naming</a></span></p><p class="c21 c23"><span class="c6 c3"><a class="c13" href="#h.gfkxhwjv2lu0">Inspecting the stack</a></span></p><p class="c21"><span class="c3 c8"><br>This applies to the gc toolchain. Besides this overview you might want to consult the </span><span class="c6 c3 c8"><a class="c13" href="https://www.google.com/url?q=http://lldb.llvm.org/tutorial.html&amp;sa=D&amp;usg=AFQjCNGb2blyHkZOSEl9qdueuYBW2fi2Nw">LLDB manual</a></span><span class="c3 c8">.</span></p><h2 class="c30 c21"><a name="h.gsf36tewhzbh"></a><span class="c28">Introduction</span></h2><p class="c21"><span class="c3">When you compile and link your Go programs with the gc toolchain on Linux, Mac OS X, FreeBSD or NetBSD, the resulting binaries contain DWARFv3 debugging information that recent versions (&gt;3.7) of the LLDB debugger can use to inspect a live process or a core dump. You will probably need to build </span><span class="c3"><a class="c13" href="https://www.google.com/url?q=http://lldb.llvm.org/build.html&amp;sa=D&amp;usg=AFQjCNGPfBykHVxp7RFNuC4dSR5tLq6fSA">LLDB from trunk</a></span><span class="c3">&nbsp;to get the go support.</span></p><p class="c5"><span class="c18 c3">Pass the </span><span class="c18 c0">&#39;-w&#39;</span><span class="c18 c3">&nbsp;flag to the linker to omit the debug information (for example, </span><span class="c18 c0">go build -ldflags &quot;-w&quot; prog.go</span><span class="c18 c3">).</span></p><p class="c5"><span class="c18 c3">The code generated by the </span><span class="c18 c39">gc</span><span class="c18 c3">&nbsp;compiler includes inlining of function invocations and registerization of variables. These optimizations make debugging with </span><span class="c18 c39">lldb</span><span class="c18 c3">&nbsp;harder. To disable them when debugging, pass the flags </span><span class="c18 c0">-gcflags &quot;-N -l&quot;</span><span class="c18 c3">&nbsp;to the </span><span class="c3 c49 c50"><a class="c13" href="https://www.google.com/url?q=https://golang.org/cmd/go&amp;sa=D&amp;usg=AFQjCNFIOVs5T3L4h2or_30j0meed25biQ">go</a></span><span class="c18 c3">&nbsp;command used to build the code being debugged.</span></p><p class="c5 c25"><span class="c3 c18"></span></p><h3 class="c5 c44"><a name="h.1utdmm7zjmva"></a><span class="c40">Getting lldb</span></h3><p class="c21"><span class="c3">The</span><span class="c3">&nbsp;latest release lldb (3.7) doesn&rsquo;t contain the go extensions, so you will need to </span><span class="c6 c3"><a class="c13" href="https://www.google.com/url?q=http://lldb.llvm.org/build.html&amp;sa=D&amp;usg=AFQjCNGPfBykHVxp7RFNuC4dSR5tLq6fSA">build it from trunk.</a></span><span class="c3 c51"><br></span></p><p class="c21"><span class="c40">Common Operations</span></p><ul class="c24 lst-kix_2gjuodkcyzyk-0 start"><li class="c15"><span class="c3">Show file and line number for code, set breakpoints and disassemble:</span></li></ul><a href="#" name="ff0e8c89fa67436f94662226fa46a2d26424096d"></a><a href="#" name="0"></a><table cellpadding="0" cellspacing="0" class="c29"><tbody><tr class="c4"><td class="c7" colspan="1" rowspan="1"><p class="c1"><span class="c0">(lldb) l<br>(lldb) l </span><span class="c0 c8">line</span><span class="c0"><br>(lldb) l </span><span class="c0 c8">file.go</span><span class="c0">:</span><span class="c0 c8">line</span><span class="c0"><br>(lldb) b </span><span class="c0 c8">line</span><span class="c0"><br>(lldb) b </span><span class="c0 c8">file.go</span><span class="c0">:</span><span class="c0 c8">line</span><span class="c2 c0"><br>(lldb) disas</span></p></td></tr></tbody></table><p class="c5 c25"><span class="c18 c3 c14"></span></p><ul class="c24 lst-kix_2gjuodkcyzyk-0"><li class="c15"><span class="c3">Show backtraces and unwind stack frames:<br></span></li></ul><a href="#" name="25fd15385b76bb1faf118c5a953c81ed9b6565eb"></a><a href="#" name="1"></a><table cellpadding="0" cellspacing="0" class="c29"><tbody><tr class="c4"><td class="c7" colspan="1" rowspan="1"><p class="c1"><span class="c0">(lldb) bt<br>(lldb) frame </span><span class="c32 c0 c8 c10 c17 c43">n</span></p></td></tr></tbody></table><p class="c5 c25"><span class="c18 c3 c14"></span></p><ul class="c24 lst-kix_2gjuodkcyzyk-0"><li class="c15"><span class="c3">Show the name, type and location on the stack frame of local variables, arguments and return values:</span></li></ul><a href="#" name="f9af66607d34da9bb964c100c63f4d4f7cfb97b3"></a><a href="#" name="2"></a><table cellpadding="0" cellspacing="0" class="c29"><tbody><tr class="c4"><td class="c7" colspan="1" rowspan="1"><p class="c1"><span class="c0">(lldb) frame variable<br>(lldb) p </span><span class="c0 c8">varname</span><span class="c0"><br>(lldb) expr -T -- </span><span class="c32 c0 c8 c10 c17 c43">varname</span></p></td></tr></tbody></table><p class="c21 c25 c48"><span class="c11 c8 c41"></span></p><h3 class="c34 c21"><a name="h.ysbfyj1xcm8z"></a><span class="c40">Go Extensions</span></h3><h4 class="c20"><a name="h.t0hx7awbcpi"></a><span class="c17 c14">Expression parsing</span></h4><p class="c21"><span class="c3">LLDB includes a simple go expression parser. <br></span></p><a href="#" name="e3d0f512db67504cabe397ee26832389cf1ed1c9"></a><a href="#" name="3"></a><table cellpadding="0" cellspacing="0" class="c36 c26"><tbody><tr class="c4"><td class="c7" colspan="1" rowspan="1"><p class="c9"><span class="c12 c0 c10">(lldb) p x</span></p><p class="c9"><span class="c12 c0 c10">(lldb) expr *(*int32)t</span></p><p class="c9"><span class="c12 c0 c10">(lldb) help expr</span></p></td></tr></tbody></table><h4 class="c20"><a name="h.hdz0ga20kehk"></a><span class="c14 c17"><br>Interfaces</span></h4><p class="c21"><span class="c3">By default, LLDB shows the dynamic type of interface values. This is usually a pointer. &nbsp;Consider </span><span class="c0">func foo(a interface{}) { ... }</span><span class="c3">. If you call </span><span class="c0">foo(1.0)</span><span class="c3">, lldb will treat </span><span class="c0">a</span><span class="c3">&nbsp;as </span><span class="c0">*float64</span><span class="c3">&nbsp;inside foo. You can disable this behavior for a single expression or globally:</span></p><p class="c21 c25"><span class="c3"></span></p><a href="#" name="76a7cd7beb6ade83664141ec3f2fdc921cf5b545"></a><a href="#" name="4"></a><table cellpadding="0" cellspacing="0" class="c33"><tbody><tr class="c4"><td class="c7" colspan="1" rowspan="1"><p class="c9"><span class="c2 c0">(lldb) expr -d no-dynamic-values -- a<br>(lldb) settings set target.prefer-dynamic-values no-dynamic-values</span></p></td></tr></tbody></table><p class="c21 c25"><span class="c3"></span></p><h4 class="c5 c44"><a name="h.e6oyh7whpt27"></a><span class="c17 c14">Data Formatters</span></h4><p class="c21"><span class="c3">LLDB includes data formatters for go strings and slices. See the </span><span class="c6 c3"><a class="c13" href="https://www.google.com/url?q=http://lldb.llvm.org/varformats.html&amp;sa=D&amp;usg=AFQjCNE29Nb70XZuTZAsP27JQEDlY1fK0Q">LLDB docs</a></span><span class="c3">&nbsp;for custom variable formatting. If you want to extend the builtin formatters, see </span><span class="c6 c3"><a class="c13" href="https://www.google.com/url?q=https://github.com/ribrdb/lldb/blob/gogogo/source/Plugins/LanguageRuntime/Go/GoLanguageRuntime.cpp&amp;sa=D&amp;usg=AFQjCNHj0EszC4OSneKLSrtAkMnc1E63VQ">GoLanguageRuntime.cpp</a></span><span class="c3">.</span></p><p class="c21"><span class="c3">Channels and maps are &#39;reference&#39; types, which lldb treats as pointers to C++-like types </span><span class="c0">hash&lt;int,string&gt;*</span><span class="c3">. Dereferencing will show the internal representation.</span></p><h4 class="c5 c37 c44"><a name="h.j0x7islcroa0"></a><span class="c17 c14">Goroutines</span></h4><p class="c21"><span class="c3">LLDB treats Goroutines as threads.</span></p><a href="#" name="ae51bd4f9f36668a0ed2e95aa4264e52a421a237"></a><a href="#" name="5"></a><table cellpadding="0" cellspacing="0" class="c36 c26"><tbody><tr class="c4"><td class="c7" colspan="1" rowspan="1"><p class="c9 c37"><span class="c12 c3 c10">(lldb) thread list</span></p><p class="c9 c37"><span class="c12 c3 c10">(lldb) bt all</span></p><p class="c9 c37"><span class="c12 c3 c10">(lldb) thread select 2</span></p></td></tr></tbody></table><h3 class="c34 c21"><a name="h.xma35v7inmhr"></a><span class="c40">Known Issues</span></h3><ul class="c24 lst-kix_kok7olkdgoid-0 start"><li class="c15"><span>Debug info is wrong when code is built with optimizations &nbsp;(the default). Make sure to add </span><span class="c0">-gcflags &quot;-N -l&quot;</span><span>&nbsp;to your </span><span class="c0">go build</span><span>&nbsp;or </span><span class="c0">go install</span><span>&nbsp;command.</span></li><li class="c15"><span>You cannot change the values of variables or call go functions</span></li><li class="c15"><span class="c3">Need better support for chan and map types</span></li><li class="c15"><span>The debug info doesn&rsquo;t include imported packages, so you need to use the full package path in expressions. When the package path includes non-identifier chars you need to quote it: &nbsp;x.(*foo/bar.BarType) or (*&ldquo;v.io/x/foo&rdquo;.FooType)(x)</span></li><li class="c15"><span>Debug info doesn&rsquo;t include scopes, so variables are visible before they&rsquo;re initialized. If there are local vars with the same name (e.g. shadowed vars), you don&rsquo;t know which is which.</span></li><li class="c15"><span>The debug info only describes the location of variables in memory. You may see stale data while variables are in registers.</span></li><li class="c15"><span>Can&rsquo;t print function types</span></li></ul><h2 class="c21 c30"><a name="h.dne486jm8zom"></a><span class="c28">Tutorial</span></h2><p class="c21"><span class="c3">In this tutorial we will inspect the binary of the </span><span class="c6 c3"><a class="c13" href="https://www.google.com/url?q=https://golang.org/pkg/regexp/&amp;sa=D&amp;usg=AFQjCNHtmoW6IBu0jHgx5bglsOOiwuEW_Q">regexp</a></span><span class="c3">&nbsp;package&#39;s unit tests. To build the binary, change to $GOROOT/src/regexp and run go test </span><span class="c18 c0">-gcflags &quot;-N -l&quot; </span><span class="c3">-c. This should produce an executable file named regexp.test.</span></p><h3 class="c34 c21"><a name="h.2nwggnckmiwr"></a><span class="c40">Getting Started</span></h3><p class="c21"><span class="c3">Launch lldb, debugging regexp.test:</span></p><a href="#" name="a5dd831faa659428b783e871554b0244d03d39fe"></a><a href="#" name="6"></a><table cellpadding="0" cellspacing="0" class="c36 c26"><tbody><tr class="c4"><td class="c7" colspan="1" rowspan="1"><p class="c1"><span class="c0">$ </span><span class="c0 c10 c17 c27">lldb regexp.test</span></p><p class="c1"><span class="c2 c0">(lldb) target create &quot;regexp.test&quot;</span></p><p class="c1"><span class="c2 c0">Current executable set to &#39;regexp.test&#39; (x86_64).</span></p><p class="c1"><span class="c0">(lldb)</span></p></td></tr></tbody></table><p class="c35 c21 c25"><span class="c11"></span></p><h3 class="c21 c34"><a name="h.ri718mqxww7e"></a><span class="c40">Setting breakpoints</span></h3><p class="c21"><span class="c3">Set a breakpoint at the TestFind function:</span></p><a href="#" name="9f617990abd4b48aefaf9e97ec732e1f50301f0c"></a><a href="#" name="7"></a><table cellpadding="0" cellspacing="0" class="c36 c26"><tbody><tr class="c4"><td class="c7" colspan="1" rowspan="1"><p class="c9"><span class="c12 c0 c10">(lldb) b regexp.TestFind</span></p></td></tr></tbody></table><p class="c21"><span class="c3"><br>Sometimes the go compiler prefixes function names with the full path. If you can&rsquo;t find the simple name, you can try using a function name regex:</span></p><a href="#" name="50c616a6ee8eca7daf4497c2b69880af4a0b6f2e"></a><a href="#" name="8"></a><table cellpadding="0" cellspacing="0" class="c33"><tbody><tr class="c4"><td class="c7" colspan="1" rowspan="1"><p class="c9"><span class="c12 c0 c10">(lldb) break set -r regexp.TestFind$</span></p><p class="c9"><span class="c12 c0 c10">Breakpoint 5: where = regexp.test`_/code/go/src/regexp.TestFind + 37 at find_test.go:149, address = 0x00000000000863a5</span></p></td></tr></tbody></table><p class="c21"><span class="c3"><br>Run the program:</span></p><a href="#" name="edd9f4b8a4ff9802588b24eef4a89e45d4b5e8b9"></a><a href="#" name="9"></a><table cellpadding="0" cellspacing="0" class="c33"><tbody><tr class="c4"><td class="c7" colspan="1" rowspan="1"><p class="c9"><span class="c0 c16">(lldb) </span><span class="c16 c0">run</span><span class="c12 c0 c19">&nbsp;--test.run=TestFind</span></p><p class="c9"><span class="c12 c0 c19">Process 8496 launched: &#39;/code/go/src/regexp/regexp.test&#39; (x86_64)</span></p><p class="c9"><span class="c12 c0 c19">Process 8496 stopped</span></p><p class="c9"><span class="c12 c0 c19">* thread #9: tid = 0x0017, 0x00000000000863a5 regexp.test`_/code/go/src/regexp.TestFind(t=0x000000020834a000) + 37 at find_test.go:149, stop reason = breakpoint 2.1 3.1 5.1</span></p><p class="c9"><span class="c12 c0 c19">&nbsp; &nbsp; frame #0: 0x00000000000863a5 regexp.test`_/code/go/src/regexp.TestFind(t=0x000000020834a000) + 37 at find_test.go:149</span></p><p class="c9"><span class="c12 c0 c19">&nbsp; &nbsp;146 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// First the simple cases.</span></p><p class="c9"><span class="c12 c0 c19">&nbsp; &nbsp;147</span></p><p class="c9"><span class="c12 c0 c19">&nbsp; &nbsp;148 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;func TestFind(t *testing.T) {</span></p><p class="c9"><span class="c12 c0 c19">-&gt; 149 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for _, test := range findTests {</span></p><p class="c9"><span class="c12 c0 c19">&nbsp; &nbsp;150 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;re := MustCompile(test.pat)</span></p><p class="c9"><span class="c12 c0 c19">&nbsp; &nbsp;151 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if re.String() != test.pat {</span></p><p class="c9"><span class="c16 c0">&nbsp; &nbsp;152 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t.Errorf(&quot;String() = `%s`; should be `%s`&quot;, re.String(), test.pat)</span></p></td></tr></tbody></table><p class="c21 c26 c25 c35"><span class="c11"></span></p><p class="c21"><span class="c3">Execution has paused at the breakpoint. See which goroutines are running, and what they&#39;re doing:</span></p><a href="#" name="f0fef912d1582b87085d81bbb1dbd864dee891f9"></a><a href="#" name="10"></a><table cellpadding="0" cellspacing="0" class="c36 c47"><tbody><tr class="c4"><td class="c7" colspan="1" rowspan="1"><p class="c9"><span class="c12 c0 c19">(lldb) thread list</span></p><p class="c9"><span class="c12 c0 c19">Process 8496 stopped</span></p><p class="c9"><span class="c12 c0 c19">&nbsp; thread #1: tid = 0x12201, 0x000000000003c0ab regexp.test`runtime.mach_semaphore_wait + 11 at sys_darwin_amd64.s:412</span></p><p class="c9"><span class="c12 c0 c19">&nbsp; thread #2: tid = 0x122fa, 0x000000000003bf7c regexp.test`runtime.usleep + 44 at sys_darwin_amd64.s:290</span></p><p class="c9"><span class="c12 c0 c19">&nbsp; thread #4: tid = 0x0001, 0x0000000000015865 regexp.test`runtime.gopark(unlockf=0x00000000000315a0, lock=0x00000002083220b8, reason=&quot;chan receive&quot;) + 261 at proc.go:131</span></p><p class="c9"><span class="c12 c0 c19">&nbsp; thread #5: tid = 0x0002, 0x0000000000015865 regexp.test`runtime.gopark(unlockf=0x00000000000315a0, lock=0x00000000002990d0, reason=&quot;force gc (idle)&quot;) + 261 at proc.go:131</span></p><p class="c9"><span class="c12 c0 c19">&nbsp; thread #6: tid = 0x0003, 0x0000000000015754 regexp.test`runtime.Gosched + 20 at proc.go:114</span></p><p class="c9"><span class="c12 c0 c19">&nbsp; thread #7: tid = 0x0004, 0x0000000000015865 regexp.test`runtime.gopark(unlockf=0x00000000000315a0, lock=0x00000000002a07d8, reason=&quot;finalizer wait&quot;) + 261 at proc.go:131</span></p><p class="c9"><span class="c16 c0">* thread #9: tid = 0x0017, 0x00000000000863a5 regexp.test`_/code/go/src/regexp.TestFind(t=0x000000020834a000) + 37 at find_test.go:149, stop reason = breakpoint 2.1 3.1 5.1</span></p></td></tr></tbody></table><p class="c21"><span class="c3">the one marked with the * is the current goroutine.</span></p><h3 class="c34 c21"><a name="h.l4wnfs5n0ijf"></a><span class="c40">Inspecting the source</span></h3><p class="c21"><span class="c3">Use the &quot;l&quot; or &quot;list&quot; command to inspect source code.</span></p><a href="#" name="384b0a1c9dbb034696e14d937dd1a003d4871f2a"></a><a href="#" name="11"></a><table cellpadding="0" cellspacing="0" class="c36 c26"><tbody><tr class="c4"><td class="c7" colspan="1" rowspan="1"><p class="c9"><span class="c12 c0 c10">(lldb) l</span></p><p class="c9"><span class="c18 c0">(lldb) </span><span class="c18 c32 c0 c8 c10 c17"># Hit enter to repeat last command. Here, list the next few lines</span></p></td></tr></tbody></table><p class="c35 c21 c25"><span class="c11"></span></p><h3 class="c34 c21"><a name="h.bfkmoyw1xf9d"></a><span class="c40">Naming</span></h3><p class="c21"><span class="c3">Variable and function names must be qualified with the name of the packages they belong to. The Compile function from the regexp package is known to lldb as &#39;regexp.Compile&#39;.</span></p><p class="c21 c25"><span class="c3"></span></p><p class="c21"><span class="c3">Methods must be qualified with the name of their receiver types. For example, the *Regexp type&rsquo;s String method is known as &#39;regexp.(*Regexp).String&#39;.</span></p><p class="c21 c25"><span class="c3"></span></p><p class="c21"><span class="c3">Variables referenced by closures will appear as pointers magically prefixed with &#39;&amp;&#39;.</span></p><h3 class="c34 c21"><a name="h.gfkxhwjv2lu0"></a><span class="c40">Inspecting the stack</span></h3><p class="c21"><span class="c3">Look at the stack trace for where we&rsquo;ve paused the program:</span></p><a href="#" name="c8f36b49d26b08c0ca0c3950f06e3ef8ded5ba60"></a><a href="#" name="12"></a><table cellpadding="0" cellspacing="0" class="c36 c38"><tbody><tr class="c4"><td class="c7" colspan="1" rowspan="1"><p class="c9"><span class="c12 c0 c19">(lldb) bt</span></p><p class="c9"><span class="c12 c0 c19">* thread #9: tid = 0x0017, 0x00000000000863a5 regexp.test`_/code/go/src/regexp.TestFind(t=0x000000020834a000) + 37 at find_test.go:149, stop reason = breakpoint 2.1 3.1 5.1</span></p><p class="c9"><span class="c12 c0 c19">&nbsp; * frame #0: 0x00000000000863a5 regexp.test`_/code/go/src/regexp.TestFind(t=0x000000020834a000) + 37 at find_test.go:149</span></p><p class="c9"><span class="c12 c0 c19">&nbsp; &nbsp; frame #1: 0x0000000000056e3f regexp.test`testing.tRunner(t=0x000000000003b671, test=0x000000020834a000) + 191 at testing.go:447</span></p><p class="c9"><span class="c12 c0 c19">&nbsp; &nbsp; frame #2: 0x00000000002995a0 regexp.test`/code/go/src/regexp.statictmp_3759 + 96</span></p><p class="c9"><span class="c12 c0 c19">&nbsp; &nbsp; frame #3: 0x000000000003b671 regexp.test`runtime.goexit + 1 at asm_amd64.s:2232</span></p><p class="c9 c25"><span class="c12 c0 c14"></span></p></td></tr></tbody></table><p class="c21 c25"><span class="c3"></span></p><p class="c21"><span class="c3">The stack frame shows we&rsquo;re currently executing the regexp.TestFind function, as expected.<br></span></p><p class="c21"><span class="c3">The command </span><span class="c0">frame variable</span><span class="c3">&nbsp;lists all variables local to the function and their values, but is a bit dangerous to use, since it will also try to print uninitialized variables. Uninitialized slices may cause lldb to try to print arbitrary large arrays.</span></p><p class="c21 c25"><span class="c3"></span></p><p class="c21"><span class="c3">The function&rsquo;s arguments:</span></p><a href="#" name="d85253109b5fbadfb4f3258f5caaaf77711afa50"></a><a href="#" name="13"></a><table cellpadding="0" cellspacing="0" class="c36 c26"><tbody><tr class="c4"><td class="c7" colspan="1" rowspan="1"><p class="c9"><span class="c12 c0 c10">(lldb) frame var -l</span></p><p class="c9"><span class="c18 c0">(*testing.T) t = 0x000000020834a000</span></p></td></tr></tbody></table><p class="c5 c26 c25"><span class="c18 c3 c14"></span></p><p class="c21"><span class="c3">When printing the argument, notice that it&rsquo;s a pointer to a Regexp value. </span></p><a href="#" name="ac03d5b01e875d55f9379c89f14a04c907231f14"></a><a href="#" name="14"></a><table cellpadding="0" cellspacing="0" class="c36 c26"><tbody><tr class="c4"><td class="c7" colspan="1" rowspan="1"><p class="c1"><span class="c2 c0">(lldb) p re</span></p><p class="c1"><span class="c2 c0">(*_/code/go/src/regexp.Regexp) $3 = 0x000000020834a090</span></p><p class="c1"><span class="c2 c0">(lldb) p t</span></p><p class="c1"><span class="c2 c0">(*testing.T) $4 = 0x000000020834a000</span></p><p class="c1"><span class="c2 c0">(lldb) p *t</span></p><p class="c1"><span class="c2 c0">(testing.T) $5 = {</span></p><p class="c1"><span class="c2 c0">&nbsp; testing.common = {</span></p><p class="c1"><span class="c2 c0">&nbsp; &nbsp; mu = {</span></p><p class="c1"><span class="c2 c0">&nbsp; &nbsp; &nbsp; w = (state = 0, sema = 0)</span></p><p class="c1"><span class="c2 c0">&nbsp; &nbsp; &nbsp; writerSem = 0</span></p><p class="c1"><span class="c2 c0">&nbsp; &nbsp; &nbsp; readerSem = 0</span></p><p class="c1"><span class="c2 c0">&nbsp; &nbsp; &nbsp; readerCount = 0</span></p><p class="c1"><span class="c2 c0">&nbsp; &nbsp; &nbsp; readerWait = 0</span></p><p class="c1"><span class="c2 c0">&nbsp; &nbsp; }</span></p><p class="c1"><span class="c2 c0">&nbsp; &nbsp; output = (len 0, cap 0) {}</span></p><p class="c1"><span class="c2 c0">&nbsp; &nbsp; failed = false</span></p><p class="c1"><span class="c2 c0">&nbsp; &nbsp; skipped = false</span></p><p class="c1"><span class="c2 c0">&nbsp; &nbsp; finished = false</span></p><p class="c1"><span class="c2 c0">&nbsp; &nbsp; start = {</span></p><p class="c1"><span class="c2 c0">&nbsp; &nbsp; &nbsp; sec = 63579066045</span></p><p class="c1"><span class="c2 c0">&nbsp; &nbsp; &nbsp; nsec = 777400918</span></p><p class="c1"><span class="c2 c0">&nbsp; &nbsp; &nbsp; loc = 0x00000000002995a0</span></p><p class="c1"><span class="c2 c0">&nbsp; &nbsp; }</span></p><p class="c1"><span class="c2 c0">&nbsp; &nbsp; duration = 0</span></p><p class="c1"><span class="c2 c0">&nbsp; &nbsp; self = 0x000000020834a000</span></p><p class="c1"><span class="c2 c0">&nbsp; &nbsp; signal = 0x0000000208322060</span></p><p class="c1"><span class="c2 c0">&nbsp; }</span></p><p class="c1"><span class="c2 c0">&nbsp; name = &quot;TestFind&quot;</span></p><p class="c1"><span class="c0">&nbsp; </span><span class="c0">startParallel =</span><span class="c2 c0">&nbsp;0x0000000208322240</span></p><p class="c1"><span class="c2 c0">}</span></p><p class="c1"><span class="c0">(lldb) </span><span class="c0">p *t.startParallel</span></p><p class="c1"><span class="c2 c0">(hchan&lt;bool&gt;) $3 = {</span></p><p class="c1"><span class="c0 c2">&nbsp; qcount = 0</span></p><p class="c1"><span class="c2 c0">&nbsp; dataqsiz = 0</span></p><p class="c1"><span class="c2 c0">&nbsp; buf = 0x0000000208322240</span></p><p class="c1"><span class="c2 c0">&nbsp; elemsize = 1</span></p><p class="c1"><span class="c2 c0">&nbsp; closed = 0</span></p><p class="c1"><span class="c2 c0">&nbsp; elemtype = 0x000000000014eda0</span></p><p class="c1"><span class="c2 c0">&nbsp; sendx = 0</span></p><p class="c1"><span class="c2 c0">&nbsp; recvx = 0</span></p><p class="c1"><span class="c2 c0">&nbsp; recvq = {</span></p><p class="c1"><span class="c2 c0">&nbsp; &nbsp; first = 0x0000000000000000</span></p><p class="c1"><span class="c2 c0">&nbsp; &nbsp; last = 0x0000000000000000</span></p><p class="c1"><span class="c2 c0">&nbsp; }</span></p><p class="c1"><span class="c2 c0">&nbsp; sendq = {</span></p><p class="c1"><span class="c2 c0">&nbsp; &nbsp; first = 0x0000000000000000</span></p><p class="c1"><span class="c2 c0">&nbsp; &nbsp; last = 0x0000000000000000</span></p><p class="c1"><span class="c2 c0">&nbsp; }</span></p><p class="c1"><span class="c2 c0">&nbsp; lock = (key = 0x0000000000000000)</span></p><p class="c1"><span class="c2 c0">}</span></p></td></tr></tbody></table><p class="c35 c21 c26 c25"><span class="c11"></span></p><p class="c5"><span class="c18 c3">That </span><span class="c18 c0">hchan&lt;bool&gt;</span><span class="c18 c3">&nbsp;is the runtime-internal representation of a channel. </span></p><p class="c5"><span class="c18 c3">Stepping forward:</span></p><a href="#" name="f4bb968a2915d6e97941bad1c1b63d5850d55712"></a><a href="#" name="15"></a><table cellpadding="0" cellspacing="0" class="c26 c36"><tbody><tr class="c4"><td class="c7" colspan="1" rowspan="1"><p class="c9"><span class="c18 c0">(lldb) </span><span class="c18 c0 c41">n</span><span class="c18 c0">&nbsp;</span><span class="c18 c32 c0 c8 c10 c17"># execute next line</span></p><p class="c9"><span class="c18 c0">(lldb) </span><span class="c18 c32 c0 c8 c10 c17"># enter is repeat</span></p><p class="c9"><span class="c18 c0">(lldb) </span><span class="c18 c0 c8 c10 c17 c32"># enter is repeat</span></p><p class="c9"><span class="c12 c0 c10">Process 17917 stopped</span></p><p class="c9"><span class="c12 c0 c10">* thread #8: tid = 0x0017, 0x000000000008648f regexp.test`_/code/go/src/regexp.TestFind(t=0x000000020834a000) + 271 at find_test.go:151, stop reason = step over</span></p><p class="c9"><span class="c12 c0 c10">&nbsp; &nbsp; frame #0: 0x000000000008648f regexp.test`_/code/go/src/regexp.TestFind(t=0x000000020834a000) + 271 at find_test.go:151</span></p><p class="c9"><span class="c12 c0 c10">&nbsp; &nbsp;148 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;func TestFind(t *testing.T) {</span></p><p class="c9"><span class="c12 c0 c10">&nbsp; &nbsp;149 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for _, test := range findTests {</span></p><p class="c9"><span class="c12 c0 c10">&nbsp; &nbsp;150 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;re := MustCompile(test.pat)</span></p><p class="c9"><span class="c12 c0 c10">-&gt; 151 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if re.String() != test.pat {</span></p><p class="c9"><span class="c12 c0 c10">&nbsp; &nbsp;152 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t.Errorf(&quot;String() = `%s`; should be `%s`&quot;, re.String(), test.pat)</span></p><p class="c9"><span class="c12 c0 c10">&nbsp; &nbsp;153 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c9"><span class="c12 c0 c10">&nbsp; &nbsp;154 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result := re.Find([]byte(test.text))</span></p><p class="c9"><span class="c12 c0 c10">(lldb) p test.pat</span></p><p class="c9"><span class="c12 c0 c10">(string) $4 = &quot;&quot;</span></p><p class="c9"><span class="c12 c0 c10">(lldb) p re</span></p><p class="c9"><span class="c12 c0 c10">(*_/code/go/src/regexp.Regexp) $5 = 0x0000000208354320</span></p><p class="c9"><span class="c12 c0 c10">(lldb) p *re</span></p><p class="c9"><span class="c12 c0 c10">(_/code/go/src/regexp.Regexp) $6 = {</span></p><p class="c9"><span class="c12 c0 c10">&nbsp; expr = &quot;&quot;</span></p><p class="c9"><span class="c12 c0 c10">&nbsp; prog = 0x0000000208ac6090</span></p><p class="c9"><span class="c12 c0 c10">&nbsp; onepass = 0x0000000000000000</span></p><p class="c9"><span class="c12 c0 c10">&nbsp; prefix = &quot;&quot;</span></p><p class="c9"><span class="c12 c0 c10">&nbsp; prefixBytes = (len 0, cap 0) {}</span></p><p class="c9"><span class="c12 c0 c10">&nbsp; prefixComplete = true</span></p><p class="c9"><span class="c12 c0 c10">&nbsp; prefixRune = 0</span></p><p class="c9"><span class="c12 c0 c10">&nbsp; prefixEnd = 0</span></p><p class="c9"><span class="c12 c0 c10">&nbsp; cond = 0</span></p><p class="c9"><span class="c12 c0 c10">&nbsp; numSubexp = 0</span></p><p class="c9"><span class="c12 c0 c10">&nbsp; subexpNames = (len 1, cap 1) {</span></p><p class="c9"><span class="c12 c0 c10">&nbsp; &nbsp; [0] = &quot;&quot;</span></p><p class="c9"><span class="c12 c0 c10">&nbsp; }</span></p><p class="c9"><span class="c12 c0 c10">&nbsp; longest = false</span></p><p class="c9"><span class="c12 c0 c10">&nbsp; mu = (state = 0, sema = 0)</span></p><p class="c9"><span class="c0 c10 c12">&nbsp; machine = (len 0, cap 0) {}</span></p><p class="c9"><span class="c12 c0 c10">}</span></p><p class="c9"><span class="c12 c0 c10">(lldb) p *re.prog</span></p><p class="c9"><span class="c12 c0 c10">(regexp/syntax.Prog) $7 = {</span></p><p class="c9"><span class="c12 c0 c10">&nbsp; Inst = (len 3, cap 4) {</span></p><p class="c9"><span class="c12 c0 c10">&nbsp; &nbsp; [0] = {</span></p><p class="c9"><span class="c12 c0 c10">&nbsp; &nbsp; &nbsp; Op = 5</span></p><p class="c9"><span class="c12 c0 c10">&nbsp; &nbsp; &nbsp; Out = 0</span></p><p class="c9"><span class="c12 c0 c10">&nbsp; &nbsp; &nbsp; Arg = 0</span></p><p class="c9"><span class="c12 c0 c10">&nbsp; &nbsp; &nbsp; Rune = (len 0, cap 0) {}</span></p><p class="c9"><span class="c12 c0 c10">&nbsp; &nbsp; }</span></p><p class="c9"><span class="c12 c0 c10">&nbsp; &nbsp; [1] = {</span></p><p class="c9"><span class="c12 c0 c10">&nbsp; &nbsp; &nbsp; Op = 6</span></p><p class="c9"><span class="c12 c0 c10">&nbsp; &nbsp; &nbsp; Out = 2</span></p><p class="c9"><span class="c12 c0 c10">&nbsp; &nbsp; &nbsp; Arg = 0</span></p><p class="c9"><span class="c12 c0 c10">&nbsp; &nbsp; &nbsp; Rune = (len 0, cap 0) {}</span></p><p class="c9"><span class="c12 c0 c10">&nbsp; &nbsp; }</span></p><p class="c9"><span class="c12 c0 c10">&nbsp; &nbsp; [2] = {</span></p><p class="c9"><span class="c12 c0 c10">&nbsp; &nbsp; &nbsp; Op = 4</span></p><p class="c9"><span class="c12 c0 c10">&nbsp; &nbsp; &nbsp; Out = 0</span></p><p class="c9"><span class="c12 c0 c10">&nbsp; &nbsp; &nbsp; Arg = 0</span></p><p class="c9"><span class="c12 c0 c10">&nbsp; &nbsp; &nbsp; Rune = (len 0, cap 0) {}</span></p><p class="c9"><span class="c12 c0 c10">&nbsp; &nbsp; }</span></p><p class="c9"><span class="c12 c0 c10">&nbsp; }</span></p><p class="c9"><span class="c12 c0 c10">&nbsp; Start = 1</span></p><p class="c9"><span class="c12 c0 c10">&nbsp; NumCap = 2</span></p><p class="c9"><span class="c18 c0">}</span></p></td></tr></tbody></table><p class="c21"><span class="c3">We can step into the Stringfunction call with &quot;s&quot;:<br></span></p><a href="#" name="8be74584d768a6029660819c2b9e73afd4549534"></a><a href="#" name="16"></a><table cellpadding="0" cellspacing="0" class="c33"><tbody><tr class="c4"><td class="c7" colspan="1" rowspan="1"><p class="c9"><span class="c12 c0 c10">(lldb) s</span></p><p class="c9"><span class="c12 c0 c10">Process 17917 stopped</span></p><p class="c9"><span class="c12 c0 c10">* thread #8: tid = 0x0017, 0x0000000000067332 regexp.test`_/code/go/src/regexp.(re=0x0000000208354320, ~r0=&quot;&quot;).String + 18 at regexp.go:104, stop reason = step in</span></p><p class="c9"><span class="c12 c0 c10">&nbsp; &nbsp; frame #0: 0x0000000000067332 regexp.test`_/code/go/src/regexp.(re=0x0000000208354320, ~r0=&quot;&quot;).String + 18 at regexp.go:104</span></p><p class="c9"><span class="c12 c0 c10">&nbsp; &nbsp;101</span></p><p class="c9"><span class="c12 c0 c10">&nbsp; &nbsp;102 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// String returns the source text used to compile the regular expression.</span></p><p class="c9"><span class="c12 c0 c10">&nbsp; &nbsp;103 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;func (re *Regexp) String() string {</span></p><p class="c9"><span class="c12 c0 c10">-&gt; 104 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return re.expr</span></p><p class="c9"><span class="c12 c0 c10">&nbsp; &nbsp;105 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c9"><span class="c12 c0 c10">&nbsp; &nbsp;106</span></p><p class="c9"><span class="c18 c0">&nbsp; &nbsp;107 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Compile parses a regular expression and returns, if successful,</span></p></td></tr></tbody></table><p class="c21"><span class="c18 c3 c14"><br></span><span class="c3">Get a stack trace to see where we are:<br></span></p><a href="#" name="e388439d3f74cbb26404c58d3db1479ad76b3e3c"></a><a href="#" name="17"></a><table cellpadding="0" cellspacing="0" class="c36 c26"><tbody><tr class="c4"><td class="c7" colspan="1" rowspan="1"><p class="c9"><span class="c12 c0 c14">(lldb) bt</span></p><p class="c9"><span class="c12 c0 c14">* thread #8: tid = 0x0017, 0x0000000000067332 regexp.test`_/code/go/src/regexp.(re=0x0000000208354320, ~r0=&quot;&quot;).String + 18 at regexp.go:104, stop reason = step in</span></p><p class="c9"><span class="c12 c0 c14">&nbsp; * frame #0: 0x0000000000067332 regexp.test`_/code/go/src/regexp.(re=0x0000000208354320, ~r0=&quot;&quot;).String + 18 at regexp.go:104</span></p><p class="c9"><span class="c12 c0 c14">&nbsp; &nbsp; frame #1: 0x00000000000864a0 regexp.test`_/code/go/src/regexp.TestFind(t=0x000000020834a000) + 288 at find_test.go:151</span></p><p class="c9"><span class="c12 c0 c14">&nbsp; &nbsp; frame #2: 0x0000000000056e3f regexp.test`testing.tRunner(t=0x000000000003b671, test=0x000000020834a000) + 191 at testing.go:447</span></p><p class="c9"><span class="c12 c0 c14">&nbsp; &nbsp; frame #3: 0x00000000002995a0 regexp.test`/code/go/src/regexp.statictmp_3759 + 96</span></p><p class="c9"><span class="c12 c0 c14">&nbsp; &nbsp; frame #4: 0x000000000003b671 regexp.test`runtime.goexit + 1 at asm_amd64.s:2232</span></p></td></tr></tbody></table><p class="c5 c25 c26"><span class="c3"></span></p><p class="c21 c25"><span class="c3 c52"></span></p></body></html>