<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#375EAB">

  <title>Debugging Go Code with LLDB</title>

<link type="text/css" rel="stylesheet" href="https://golang.org/lib/godoc/style.css">
<script type="text/javascript">window.initFuncs = [];</script>

<div id="page" class="wide">
<div class="container">

<h1>Debugging Go Code with LLDB</h1>
<p><i>Updated Jan 4, 2016</i></p>

<div id="nav"></div>

<p><i>
This applies to the <code>gc</code> toolchain. Besides this overview you might want to consult the <a href="https://www.google.com/url?q=http://lldb.llvm.org/tutorial.html&amp;sa=D&amp;usg=AFQjCNGb2blyHkZOSEl9qdueuYBW2fi2Nw">LLDB manual</a>.</i></p>

<h2 id="Introduction">Introduction</h2>

<p>When you compile and link your Go programs with the gc toolchain on Linux, Mac OS X, FreeBSD or NetBSD, the resulting binaries contain DWARFv3 debugging information that recent versions (&gt;3.7) of the LLDB debugger can use to inspect a live process or a core dump. You will probably need to build <a href="https://www.google.com/url?q=http://lldb.llvm.org/build.html&amp;sa=D&amp;usg=AFQjCNGPfBykHVxp7RFNuC4dSR5tLq6fSA">LLDB from trunk</a> to get the go support.</p>

<p>Pass the <code>&#39;-w&#39;</code> flag to the linker to omit the debug information (for example, <code>go build -ldflags &quot;-w&quot; prog.go</code>).</p>

<p>The code generated by the <code>gc</code> compiler includes inlining of function invocations and registerization of variables. These optimizations make debugging with lldb harder. To disable them when debugging, pass the flags <code>-gcflags &quot;-N -l&quot;</code> to the <a href="https://golang.org/cmd/go">go</a> command used to build the code being debugged.</p>


<h3 id=GettingLLDB>Getting lldb</h3>

<p>The latest release lldb (3.7) doesn&rsquo;t contain the go extensions, so you will need to <a href="https://www.google.com/url?q=http://lldb.llvm.org/build.html&amp;sa=D&amp;usg=AFQjCNGPfBykHVxp7RFNuC4dSR5tLq6fSA">build it from trunk.</a></p>

<h3>Common Operations</h3>

<ul>
	<li>Show file and line number for code, set breakpoints and disassemble<pre>(lldb) l
(lldb) l line
(lldb) l file.go:line
(lldb) b line
(lldb) b file.go:line
(lldb) disas</pre></li>
	<li>Show backtraces and unwind stack frames:
			<pre>(lldb) bt
(lldb) frame n</pre></li>
	<li>Show the name, type and location on the stack frame of local variables, arguments and return values:
<pre>(lldb) frame variable
(lldb) p varname
(lldb) expr -T -- varname</pre></li></ul>

<h3 id=GoExtensions>Go Extensions</h3>

<h4 id=ExpressionParsing>Expression Parsing</h4>

<p>LLDB includes a go expression parser. 

<pre>(lldb) p x
(lldb) expr *(*int32)(t)
(lldb) help expr</pre></p>

<h4 id=Interfaces>Interfaces</h4>

<p>By default, LLDB shows the dynamic type of interface values. This is usually a pointer. Consider <code>func foo(a interface{}) { ... }</code>. If you call<code>foo(1.0)</code>, lldb will treat <code>a</code> as <code>*float64</code>inside foo. You can disable this behavior for a single expression or globally:

<pre>(lldb) expr -d no-dynamic-values -- a
(lldb) settings set target.prefer-dynamic-values no-dynamic-values</pre>

<h4 id="DataFormatters">Data Formatters</h4>

<p>LLDB includes data formatters for go strings and slices. See the <a href="https://www.google.com/url?q=http://lldb.llvm.org/varformats.html&amp;sa=D&amp;usg=AFQjCNE29Nb70XZuTZAsP27JQEDlY1fK0Q">LLDB docs</a> for custom variable formatting. If you want to extend the builtin formatters, see <a href="https://github.com/ribrdb/lldb/blob/gogogo/source/Plugins/LanguageRuntime/Go/GoLanguageRuntime.cpp">GoLanguageRuntime.cpp</a>.</p>

<p>Channels and maps are &#39;reference&#39; types, which lldb treats as pointers to C++-like types <code>hash&lt;int,string&gt;*</code>. Dereferencing will show the internal representation.</p>

<h4 id=Goroutines>Goroutines</h4>

<p>LLDB treats Goroutines as threads.

<pre>(lldb) thread list
(lldb) bt all
(lldb) thread select 2</pre>

<h3 id=KnownIssues>Known Issues</h3>

<ul>
	<li>Debug info is wrong when code is built with optimizations  (the default). Make sure to add <code>-gcflags &quot;-N -l&quot;</code> to your <code>go build</code> or <code>go install</code> command.</li>
	<li>You cannot change the values of variables or call go functions</li>
	<li>Need better support for chan and map types</li>
	<li>The debug info doesn&rsquo;t include imported packages, so you need to use the full package path in expressions. When the package path includes non-identifier chars you need to quote it:  <code>x.(*foo/bar.BarType)</code> or <code>(*&ldquo;v.io/x/foo&rdquo;.FooType)(x)</code></li>
	<li>Debug info doesn&rsquo;t include scopes, so variables are visible before they&rsquo;re initialized. If there are local vars with the same name (e.g. shadowed vars), you don&rsquo;t know which is which.</li>
	<li>The debug info only describes the location of variables in memory. You may see stale data while variables are in registers.</li>
	<li>Can&rsquo;t print function types</li>
</ul>

<h2 id=Tutorial>Tutorial</h2>

<p>In this tutorial we will inspect the binary of the <a href="https://www.google.com/url?q=https://golang.org/pkg/regexp/&amp;sa=D&amp;usg=AFQjCNHtmoW6IBu0jHgx5bglsOOiwuEW_Q">regexp</a> package&#39;s unit tests. To build the binary, change to $GOROOT/src/regexp and run <code>go test -gcflags &quot;-N -l&quot; -c</code>. This should produce an executable file named regexp.test.

<h3 id=GettingStarted>Getting Started</h3>

<p>Launch lldb, debugging regexp.test:

<pre>$ lldb regexp.test
(lldb) target create &quot;regexp.test&quot;
Current executable set to &#39;regexp.test&#39; (x86_64).
(lldb)</pre>

<h3 id=Breakpoints>Setting breakpoints</h3>

<p>Set a breakpoint at the TestFind function:

<pre>(lldb) b regexp.TestFind</pre>

<p>
Sometimes the go compiler prefixes function names with the full path. If you can&rsquo;t find the simple name, you can try using a function name regex:

<pre>
(lldb) break set -r regexp.TestFind$
Breakpoint 5: where = regexp.test`_/code/go/src/regexp.TestFind + 37 at find_test.go:149, address = 0x00000000000863a5</pre>

<p>
Run the program:

<pre>(lldb) run --test.run=TestFind
Process 8496 launched: &#39;/code/go/src/regexp/regexp.test&#39; (x86_64)
Process 8496 stopped
* thread #9: tid = 0x0017, 0x00000000000863a5 regexp.test`_/code/go/src/regexp.TestFind(t=0x000000020834a000) + 37 at find_test.go:149, stop reason = breakpoint 2.1 3.1 5.1
    frame #0: 0x00000000000863a5 regexp.test`_/code/go/src/regexp.TestFind(t=0x000000020834a000) + 37 at find_test.go:149
   146         // First the simple cases.
   147
   148         func TestFind(t *testing.T) {
-&gt; 149                 for _, test := range findTests {
   150                         re := MustCompile(test.pat)
   151                         if re.String() != test.pat {
   152                                 t.Errorf(&quot;String() = `%s`; should be `%s`&quot;, re.String(), test.pat)</pre>

<p>Execution has paused at the breakpoint. See which goroutines are running, and what they&#39;re doing:

<pre>(lldb) thread list
Process 8496 stopped
  thread #1: tid = 0x12201, 0x000000000003c0ab regexp.test`runtime.mach_semaphore_wait + 11 at sys_darwin_amd64.s:412
  thread #2: tid = 0x122fa, 0x000000000003bf7c regexp.test`runtime.usleep + 44 at sys_darwin_amd64.s:290
  thread #4: tid = 0x0001, 0x0000000000015865 regexp.test`runtime.gopark(unlockf=0x00000000000315a0, lock=0x00000002083220b8, reason=&quot;chan receive&quot;) + 261 at proc.go:131
  thread #5: tid = 0x0002, 0x0000000000015865 regexp.test`runtime.gopark(unlockf=0x00000000000315a0, lock=0x00000000002990d0, reason=&quot;force gc (idle)&quot;) + 261 at proc.go:131
  thread #6: tid = 0x0003, 0x0000000000015754 regexp.test`runtime.Gosched + 20 at proc.go:114
  thread #7: tid = 0x0004, 0x0000000000015865 regexp.test`runtime.gopark(unlockf=0x00000000000315a0, lock=0x00000000002a07d8, reason=&quot;finalizer wait&quot;) + 261 at proc.go:131
* thread #9: tid = 0x0017, 0x00000000000863a5 regexp.test`_/code/go/src/regexp.TestFind(t=0x000000020834a000) + 37 at find_test.go:149, stop reason = breakpoint 2.1 3.1 5.1</pre>

<p>the one marked with the * is the current goroutine.

<h3 id=InspectingSource>Inspecting the Source</h3>

<p>Use the &quot;l&quot; or &quot;list&quot; command to inspect source code.

<pre>(lldb) l
(lldb) # Hit enter to repeat last command. Here, list the next few lines</pre>


<h3 id=Naming>Naming</h3>

<p>Variable and function names must be qualified with the name of the packages they belong to. The Compile function from the regexp package is known to lldb as &#39;regexp.Compile&#39;.


<p>Methods must be qualified with the name of their receiver types. For example, the *Regexp type&rsquo;s String method is known as &#39;regexp.(*Regexp).String&#39;.


<p>Variables referenced by closures will appear as pointers magically prefixed with &#39;&amp;&#39;.

<h3><a name="h.gfkxhwjv2lu0"></a>Inspecting the stack</h3>

<p>Look at the stack trace for where we&rsquo;ve paused the program:

<pre>(lldb) bt
* thread #9: tid = 0x0017, 0x00000000000863a5 regexp.test`_/code/go/src/regexp.TestFind(t=0x000000020834a000) + 37 at find_test.go:149, stop reason = breakpoint 2.1 3.1 5.1
  * frame #0: 0x00000000000863a5 regexp.test`_/code/go/src/regexp.TestFind(t=0x000000020834a000) + 37 at find_test.go:149
    frame #1: 0x0000000000056e3f regexp.test`testing.tRunner(t=0x000000000003b671, test=0x000000020834a000) + 191 at testing.go:447
    frame #2: 0x00000000002995a0 regexp.test`/code/go/src/regexp.statictmp_3759 + 96
    frame #3: 0x000000000003b671 regexp.test`runtime.goexit + 1 at asm_amd64.s:2232</pre>


<p>The stack frame shows we&rsquo;re currently executing the regexp.TestFind function, as expected.

<p>The command <code>frame variable</code> lists all variables local to the function and their values, but is a bit dangerous to use, since it will also try to print uninitialized variables. Uninitialized slices may cause lldb to try to print arbitrary large arrays.


<p>The function&rsquo;s arguments:

<pre>(lldb) frame var -l
(*testing.T) t = 0x000000020834a000</pre>


<p>When printing the argument, notice that it&rsquo;s a pointer to a Regexp value.

<pre>(lldb) p re
(*_/code/go/src/regexp.Regexp) $3 = 0x000000020834a090
(lldb) p t
(*testing.T) $4 = 0x000000020834a000
(lldb) p *t
(testing.T) $5 = {
  testing.common = {
    mu = {
      w = (state = 0, sema = 0)
      writerSem = 0
      readerSem = 0
      readerCount = 0
      readerWait = 0
    }
    output = (len 0, cap 0) {}
    failed = false
    skipped = false
    finished = false
    start = {
      sec = 63579066045
      nsec = 777400918
      loc = 0x00000000002995a0
    }
    duration = 0
    self = 0x000000020834a000
    signal = 0x0000000208322060
  }
  name = &quot;TestFind&quot;
  startParallel = 0x0000000208322240
}
(lldb) p *t.startParallel
(hchan&lt;bool&gt;) $3 = {
  qcount = 0
  dataqsiz = 0
  buf = 0x0000000208322240
  elemsize = 1
  closed = 0
  elemtype = 0x000000000014eda0
  sendx = 0
  recvx = 0
  recvq = {
    first = 0x0000000000000000
    last = 0x0000000000000000
  }
  sendq = {
    first = 0x0000000000000000
    last = 0x0000000000000000
  }
  lock = (key = 0x0000000000000000)
}</pre>


<p>That <code>hchan&lt;bool&gt;</code> is the runtime-internal representation of a channel.

<p>Stepping forward:

<pre>(lldb) n # execute next line
(lldb) # enter is repeat
(lldb) # enter is repeat
Process 17917 stopped
* thread #8: tid = 0x0017, 0x000000000008648f regexp.test`_/code/go/src/regexp.TestFind(t=0x000000020834a000) + 271 at find_test.go:151, stop reason = step over
    frame #0: 0x000000000008648f regexp.test`_/code/go/src/regexp.TestFind(t=0x000000020834a000) + 271 at find_test.go:151
   148         func TestFind(t *testing.T) {
   149                 for _, test := range findTests {
   150                         re := MustCompile(test.pat)
-&gt; 151                         if re.String() != test.pat {
   152                                 t.Errorf(&quot;String() = `%s`; should be `%s`&quot;, re.String(), test.pat)
   153                         }
   154                         result := re.Find([]byte(test.text))
(lldb) p test.pat
(string) $4 = &quot;&quot;
(lldb) p re
(*_/code/go/src/regexp.Regexp) $5 = 0x0000000208354320
(lldb) p *re
(_/code/go/src/regexp.Regexp) $6 = {
  expr = &quot;&quot;
  prog = 0x0000000208ac6090
  onepass = 0x0000000000000000
  prefix = &quot;&quot;
  prefixBytes = (len 0, cap 0) {}
  prefixComplete = true
  prefixRune = 0
  prefixEnd = 0
  cond = 0
  numSubexp = 0
  subexpNames = (len 1, cap 1) {
    [0] = &quot;&quot;
  }
  longest = false
  mu = (state = 0, sema = 0)
  machine = (len 0, cap 0) {}
}
(lldb) p *re.prog
(regexp/syntax.Prog) $7 = {
  Inst = (len 3, cap 4) {
    [0] = {
      Op = 5
      Out = 0
      Arg = 0
      Rune = (len 0, cap 0) {}
    }
    [1] = {
      Op = 6
      Out = 2
      Arg = 0
      Rune = (len 0, cap 0) {}
    }
    [2] = {
      Op = 4
      Out = 0
      Arg = 0
      Rune = (len 0, cap 0) {}
    }
  }
  Start = 1
  NumCap = 2
}</pre>

<p>We can step into the Stringfunction call with &quot;s&quot;:

<pre>(lldb) s
Process 17917 stopped
* thread #8: tid = 0x0017, 0x0000000000067332 regexp.test`_/code/go/src/regexp.(re=0x0000000208354320, ~r0=&quot;&quot;).String + 18 at regexp.go:104, stop reason = step in
    frame #0: 0x0000000000067332 regexp.test`_/code/go/src/regexp.(re=0x0000000208354320, ~r0=&quot;&quot;).String + 18 at regexp.go:104
   101
   102         // String returns the source text used to compile the regular expression.
   103         func (re *Regexp) String() string {
-&gt; 104                 return re.expr
   105         }
   106
   107         // Compile parses a regular expression and returns, if successful,</pre>
<p>
Get a stack trace to see where we are:

<pre>(lldb) bt
* thread #8: tid = 0x0017, 0x0000000000067332 regexp.test`_/code/go/src/regexp.(re=0x0000000208354320, ~r0=&quot;&quot;).String + 18 at regexp.go:104, stop reason = step in
  * frame #0: 0x0000000000067332 regexp.test`_/code/go/src/regexp.(re=0x0000000208354320, ~r0=&quot;&quot;).String + 18 at regexp.go:104
    frame #1: 0x00000000000864a0 regexp.test`_/code/go/src/regexp.TestFind(t=0x000000020834a000) + 288 at find_test.go:151
    frame #2: 0x0000000000056e3f regexp.test`testing.tRunner(t=0x000000000003b671, test=0x000000020834a000) + 191 at testing.go:447
    frame #3: 0x00000000002995a0 regexp.test`/code/go/src/regexp.statictmp_3759 + 96
    frame #4: 0x000000000003b671 regexp.test`runtime.goexit + 1 at asm_amd64.s:2232</pre>

<div id="footer">
Portions of this page are modifications based on the <a href="https://golang.org/doc/gdb">Go GDB Tutorial</a> and used according to terms described in the <a href="http://creativecommons.org/licenses/by/3.0/">Creative Commons 3.0 Attribution License</a>.
</div>
</div><!-- .container -->
</div><!-- #page -->

<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
<script type="text/javascript" src="https://golang.org/lib/godoc/godocs.js"></script>
