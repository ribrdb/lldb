//===-- GoAST.h -------------------------------------------------*- C++ -*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

// DO NOT EDIT.
// Generated by gen_go_ast.py

#ifndef liblldb_GoAST_h
#define liblldb_GoAST_h

#include "lldb/lldb-forward.h"
#include "lldb/lldb-private.h"
#include "lldb/Expression/GoLexer.h"

namespace lldb_private {

class GoASTNode {
public:
    typedef GoLexer::TokenType TokenType;
    typedef GoLexer::Token Token;
    enum ChanDir {
       eChanBidir,
       eChanSend,
       eChanRecv,
    };
    enum NodeKind
    {
        eBadDecl,
        eFuncDecl,
        eGenDecl,
        eArrayType,
        eBadExpr,
        eBasicLit,
        eBinaryExpr,
        eIdent,
        eCallExpr,
        eChanType,
        eCompositeLit,
        eEllipsis,
        eFuncType,
        eFuncLit,
        eIndexExpr,
        eInterfaceType,
        eKeyValueExpr,
        eMapType,
        eParenExpr,
        eSelectorExpr,
        eSliceExpr,
        eStarExpr,
        eStructType,
        eTypeAssertExpr,
        eUnaryExpr,
        eImportSpec,
        eTypeSpec,
        eValueSpec,
        eAssignStmt,
        eBadStmt,
        eBlockStmt,
        eBranchStmt,
        eCaseClause,
        eCommClause,
        eDeclStmt,
        eDeferStmt,
        eEmptyStmt,
        eExprStmt,
        eForStmt,
        eGoStmt,
        eIfStmt,
        eIncDecStmt,
        eLabeledStmt,
        eRangeStmt,
        eReturnStmt,
        eSelectStmt,
        eSendStmt,
        eSwitchStmt,
        eTypeSwitchStmt,
        eField,
        eFieldList,
    };

    virtual ~GoASTNode() { }

    NodeKind GetKind() const { return m_kind; }

    virtual const char* GetKindName() const = 0;

protected:
    explicit GoASTNode(NodeKind kind) : m_kind(kind) { }

private:
    const NodeKind m_kind;
    
    GoASTNode(const GoASTNode&) = delete;
    const GoASTNode& operator=(const GoASTNode&) = delete;
};


class GoASTDecl : public GoASTNode
{
public:
    template <typename R, typename V>
    R Visit(V* v) const;

    static bool
    classof(const GoASTNode* n) { return n->GetKind() >= eBadDecl && n->GetKind() <= eGenDecl; }

protected:
    explicit GoASTDecl(NodeKind kind) : GoASTNode(kind) { }
private:

    GoASTDecl(const GoASTDecl&) = delete;
    const GoASTDecl& operator=(const GoASTDecl&) = delete;
};

class GoASTExpr : public GoASTNode
{
public:
    template <typename R, typename V>
    R Visit(V* v) const;

    static bool
    classof(const GoASTNode* n) { return n->GetKind() >= eArrayType && n->GetKind() <= eUnaryExpr; }

protected:
    explicit GoASTExpr(NodeKind kind) : GoASTNode(kind) { }
private:

    GoASTExpr(const GoASTExpr&) = delete;
    const GoASTExpr& operator=(const GoASTExpr&) = delete;
};

class GoASTSpec : public GoASTNode
{
public:
    template <typename R, typename V>
    R Visit(V* v) const;

    static bool
    classof(const GoASTNode* n) { return n->GetKind() >= eImportSpec && n->GetKind() <= eValueSpec; }

protected:
    explicit GoASTSpec(NodeKind kind) : GoASTNode(kind) { }
private:

    GoASTSpec(const GoASTSpec&) = delete;
    const GoASTSpec& operator=(const GoASTSpec&) = delete;
};

class GoASTStmt : public GoASTNode
{
public:
    template <typename R, typename V>
    R Visit(V* v) const;

    static bool
    classof(const GoASTNode* n) { return n->GetKind() >= eAssignStmt && n->GetKind() <= eTypeSwitchStmt; }

protected:
    explicit GoASTStmt(NodeKind kind) : GoASTNode(kind) { }
private:

    GoASTStmt(const GoASTStmt&) = delete;
    const GoASTStmt& operator=(const GoASTStmt&) = delete;
};


class GoASTArrayType : public GoASTExpr
{
public:
    GoASTArrayType(GoASTExpr* len, GoASTExpr* elt) : GoASTExpr(eArrayType), m_len(len), m_elt(elt) {}
    virtual ~GoASTArrayType() { }

    const char* GetKindName() const { return "ArrayType"; }

    static bool
    classof(const GoASTNode* n) { return n->GetKind() == eArrayType; }
    
    const GoASTExpr* GetLen() const { return m_len.get(); }
    void SetLen(GoASTExpr* len) { m_len.reset(len); }

    const GoASTExpr* GetElt() const { return m_elt.get(); }
    void SetElt(GoASTExpr* elt) { m_elt.reset(elt); }

private:
    std::unique_ptr<GoASTExpr> m_len;
    std::unique_ptr<GoASTExpr> m_elt;

    GoASTArrayType(const GoASTArrayType&) = delete;
    const GoASTArrayType& operator=(const GoASTArrayType&) = delete;
};

class GoASTAssignStmt : public GoASTStmt
{
public:
    GoASTAssignStmt() : GoASTStmt(eAssignStmt) {}
    virtual ~GoASTAssignStmt() { }

    const char* GetKindName() const { return "AssignStmt"; }

    static bool
    classof(const GoASTNode* n) { return n->GetKind() == eAssignStmt; }
    
    size_t NumLhs() const { return m_lhs.size(); }
    const GoASTExpr* GetLhs(int i) const { return m_lhs[i].get(); }
    void AddLhs(GoASTExpr* lhs) { m_lhs.push_back(std::unique_ptr<GoASTExpr>(lhs)); }

    size_t NumRhs() const { return m_rhs.size(); }
    const GoASTExpr* GetRhs(int i) const { return m_rhs[i].get(); }
    void AddRhs(GoASTExpr* rhs) { m_rhs.push_back(std::unique_ptr<GoASTExpr>(rhs)); }

    bool GetDefine() const { return m_define; }
    void SetDefine(bool define) { m_define = define; }

private:
    std::vector<std::unique_ptr<GoASTExpr> > m_lhs;
    std::vector<std::unique_ptr<GoASTExpr> > m_rhs;
    bool m_define;

    GoASTAssignStmt(const GoASTAssignStmt&) = delete;
    const GoASTAssignStmt& operator=(const GoASTAssignStmt&) = delete;
};

class GoASTBadDecl : public GoASTDecl
{
public:
    GoASTBadDecl() : GoASTDecl(eBadDecl) {}
    virtual ~GoASTBadDecl() { }

    const char* GetKindName() const { return "BadDecl"; }

    static bool
    classof(const GoASTNode* n) { return n->GetKind() == eBadDecl; }
    
private:

    GoASTBadDecl(const GoASTBadDecl&) = delete;
    const GoASTBadDecl& operator=(const GoASTBadDecl&) = delete;
};

class GoASTBadExpr : public GoASTExpr
{
public:
    GoASTBadExpr() : GoASTExpr(eBadExpr) {}
    virtual ~GoASTBadExpr() { }

    const char* GetKindName() const { return "BadExpr"; }

    static bool
    classof(const GoASTNode* n) { return n->GetKind() == eBadExpr; }
    
private:

    GoASTBadExpr(const GoASTBadExpr&) = delete;
    const GoASTBadExpr& operator=(const GoASTBadExpr&) = delete;
};

class GoASTBadStmt : public GoASTStmt
{
public:
    GoASTBadStmt() : GoASTStmt(eBadStmt) {}
    virtual ~GoASTBadStmt() { }

    const char* GetKindName() const { return "BadStmt"; }

    static bool
    classof(const GoASTNode* n) { return n->GetKind() == eBadStmt; }
    
private:

    GoASTBadStmt(const GoASTBadStmt&) = delete;
    const GoASTBadStmt& operator=(const GoASTBadStmt&) = delete;
};

class GoASTBasicLit : public GoASTExpr
{
public:
    explicit GoASTBasicLit(Token value) : GoASTExpr(eBasicLit), m_value(value) {}
    virtual ~GoASTBasicLit() { }

    const char* GetKindName() const { return "BasicLit"; }

    static bool
    classof(const GoASTNode* n) { return n->GetKind() == eBasicLit; }
    
    Token GetValue() const { return m_value; }
    void SetValue(Token value) { m_value = value; }

private:
    Token m_value;

    GoASTBasicLit(const GoASTBasicLit&) = delete;
    const GoASTBasicLit& operator=(const GoASTBasicLit&) = delete;
};

class GoASTBinaryExpr : public GoASTExpr
{
public:
    GoASTBinaryExpr(GoASTExpr* x, GoASTExpr* y, TokenType op) : GoASTExpr(eBinaryExpr), m_x(x), m_y(y), m_op(op) {}
    virtual ~GoASTBinaryExpr() { }

    const char* GetKindName() const { return "BinaryExpr"; }

    static bool
    classof(const GoASTNode* n) { return n->GetKind() == eBinaryExpr; }
    
    const GoASTExpr* GetX() const { return m_x.get(); }
    void SetX(GoASTExpr* x) { m_x.reset(x); }

    const GoASTExpr* GetY() const { return m_y.get(); }
    void SetY(GoASTExpr* y) { m_y.reset(y); }

    TokenType GetOp() const { return m_op; }
    void SetOp(TokenType op) { m_op = op; }

private:
    std::unique_ptr<GoASTExpr> m_x;
    std::unique_ptr<GoASTExpr> m_y;
    TokenType m_op;

    GoASTBinaryExpr(const GoASTBinaryExpr&) = delete;
    const GoASTBinaryExpr& operator=(const GoASTBinaryExpr&) = delete;
};

class GoASTBlockStmt : public GoASTStmt
{
public:
    GoASTBlockStmt() : GoASTStmt(eBlockStmt) {}
    virtual ~GoASTBlockStmt() { }

    const char* GetKindName() const { return "BlockStmt"; }

    static bool
    classof(const GoASTNode* n) { return n->GetKind() == eBlockStmt; }
    
    size_t NumList() const { return m_list.size(); }
    const GoASTStmt* GetList(int i) const { return m_list[i].get(); }
    void AddList(GoASTStmt* list) { m_list.push_back(std::unique_ptr<GoASTStmt>(list)); }

private:
    std::vector<std::unique_ptr<GoASTStmt> > m_list;

    GoASTBlockStmt(const GoASTBlockStmt&) = delete;
    const GoASTBlockStmt& operator=(const GoASTBlockStmt&) = delete;
};

class GoASTIdent : public GoASTExpr
{
public:
    explicit GoASTIdent(Token name) : GoASTExpr(eIdent), m_name(name) {}
    virtual ~GoASTIdent() { }

    const char* GetKindName() const { return "Ident"; }

    static bool
    classof(const GoASTNode* n) { return n->GetKind() == eIdent; }
    
    Token GetName() const { return m_name; }
    void SetName(Token name) { m_name = name; }

private:
    Token m_name;

    GoASTIdent(const GoASTIdent&) = delete;
    const GoASTIdent& operator=(const GoASTIdent&) = delete;
};

class GoASTBranchStmt : public GoASTStmt
{
public:
    GoASTBranchStmt(GoASTIdent* label, TokenType tok) : GoASTStmt(eBranchStmt), m_label(label), m_tok(tok) {}
    virtual ~GoASTBranchStmt() { }

    const char* GetKindName() const { return "BranchStmt"; }

    static bool
    classof(const GoASTNode* n) { return n->GetKind() == eBranchStmt; }
    
    const GoASTIdent* GetLabel() const { return m_label.get(); }
    void SetLabel(GoASTIdent* label) { m_label.reset(label); }

    TokenType GetTok() const { return m_tok; }
    void SetTok(TokenType tok) { m_tok = tok; }

private:
    std::unique_ptr<GoASTIdent> m_label;
    TokenType m_tok;

    GoASTBranchStmt(const GoASTBranchStmt&) = delete;
    const GoASTBranchStmt& operator=(const GoASTBranchStmt&) = delete;
};

class GoASTCallExpr : public GoASTExpr
{
public:
    GoASTCallExpr() : GoASTExpr(eCallExpr) {}
    virtual ~GoASTCallExpr() { }

    const char* GetKindName() const { return "CallExpr"; }

    static bool
    classof(const GoASTNode* n) { return n->GetKind() == eCallExpr; }
    
    const GoASTExpr* GetFun() const { return m_fun.get(); }
    void SetFun(GoASTExpr* fun) { m_fun.reset(fun); }

    size_t NumArgs() const { return m_args.size(); }
    const GoASTExpr* GetArgs(int i) const { return m_args[i].get(); }
    void AddArgs(GoASTExpr* args) { m_args.push_back(std::unique_ptr<GoASTExpr>(args)); }

    bool GetEllipsis() const { return m_ellipsis; }
    void SetEllipsis(bool ellipsis) { m_ellipsis = ellipsis; }

private:
    std::unique_ptr<GoASTExpr> m_fun;
    std::vector<std::unique_ptr<GoASTExpr> > m_args;
    bool m_ellipsis;

    GoASTCallExpr(const GoASTCallExpr&) = delete;
    const GoASTCallExpr& operator=(const GoASTCallExpr&) = delete;
};

class GoASTCaseClause : public GoASTStmt
{
public:
    GoASTCaseClause() : GoASTStmt(eCaseClause) {}
    virtual ~GoASTCaseClause() { }

    const char* GetKindName() const { return "CaseClause"; }

    static bool
    classof(const GoASTNode* n) { return n->GetKind() == eCaseClause; }
    
    size_t NumList() const { return m_list.size(); }
    const GoASTExpr* GetList(int i) const { return m_list[i].get(); }
    void AddList(GoASTExpr* list) { m_list.push_back(std::unique_ptr<GoASTExpr>(list)); }

    size_t NumBody() const { return m_body.size(); }
    const GoASTStmt* GetBody(int i) const { return m_body[i].get(); }
    void AddBody(GoASTStmt* body) { m_body.push_back(std::unique_ptr<GoASTStmt>(body)); }

private:
    std::vector<std::unique_ptr<GoASTExpr> > m_list;
    std::vector<std::unique_ptr<GoASTStmt> > m_body;

    GoASTCaseClause(const GoASTCaseClause&) = delete;
    const GoASTCaseClause& operator=(const GoASTCaseClause&) = delete;
};

class GoASTChanType : public GoASTExpr
{
public:
    GoASTChanType(ChanDir dir, GoASTExpr* value) : GoASTExpr(eChanType), m_dir(dir), m_value(value) {}
    virtual ~GoASTChanType() { }

    const char* GetKindName() const { return "ChanType"; }

    static bool
    classof(const GoASTNode* n) { return n->GetKind() == eChanType; }
    
    ChanDir GetDir() const { return m_dir; }
    void SetDir(ChanDir dir) { m_dir = dir; }

    const GoASTExpr* GetValue() const { return m_value.get(); }
    void SetValue(GoASTExpr* value) { m_value.reset(value); }

private:
    ChanDir m_dir;
    std::unique_ptr<GoASTExpr> m_value;

    GoASTChanType(const GoASTChanType&) = delete;
    const GoASTChanType& operator=(const GoASTChanType&) = delete;
};

class GoASTCommClause : public GoASTStmt
{
public:
    GoASTCommClause() : GoASTStmt(eCommClause) {}
    virtual ~GoASTCommClause() { }

    const char* GetKindName() const { return "CommClause"; }

    static bool
    classof(const GoASTNode* n) { return n->GetKind() == eCommClause; }
    
    const GoASTStmt* GetComm() const { return m_comm.get(); }
    void SetComm(GoASTStmt* comm) { m_comm.reset(comm); }

    size_t NumBody() const { return m_body.size(); }
    const GoASTStmt* GetBody(int i) const { return m_body[i].get(); }
    void AddBody(GoASTStmt* body) { m_body.push_back(std::unique_ptr<GoASTStmt>(body)); }

private:
    std::unique_ptr<GoASTStmt> m_comm;
    std::vector<std::unique_ptr<GoASTStmt> > m_body;

    GoASTCommClause(const GoASTCommClause&) = delete;
    const GoASTCommClause& operator=(const GoASTCommClause&) = delete;
};

class GoASTCompositeLit : public GoASTExpr
{
public:
    GoASTCompositeLit() : GoASTExpr(eCompositeLit) {}
    virtual ~GoASTCompositeLit() { }

    const char* GetKindName() const { return "CompositeLit"; }

    static bool
    classof(const GoASTNode* n) { return n->GetKind() == eCompositeLit; }
    
    const GoASTExpr* GetType() const { return m_type.get(); }
    void SetType(GoASTExpr* type) { m_type.reset(type); }

    size_t NumElts() const { return m_elts.size(); }
    const GoASTExpr* GetElts(int i) const { return m_elts[i].get(); }
    void AddElts(GoASTExpr* elts) { m_elts.push_back(std::unique_ptr<GoASTExpr>(elts)); }

private:
    std::unique_ptr<GoASTExpr> m_type;
    std::vector<std::unique_ptr<GoASTExpr> > m_elts;

    GoASTCompositeLit(const GoASTCompositeLit&) = delete;
    const GoASTCompositeLit& operator=(const GoASTCompositeLit&) = delete;
};

class GoASTDeclStmt : public GoASTStmt
{
public:
    explicit GoASTDeclStmt(GoASTDecl* decl) : GoASTStmt(eDeclStmt), m_decl(decl) {}
    virtual ~GoASTDeclStmt() { }

    const char* GetKindName() const { return "DeclStmt"; }

    static bool
    classof(const GoASTNode* n) { return n->GetKind() == eDeclStmt; }
    
    const GoASTDecl* GetDecl() const { return m_decl.get(); }
    void SetDecl(GoASTDecl* decl) { m_decl.reset(decl); }

private:
    std::unique_ptr<GoASTDecl> m_decl;

    GoASTDeclStmt(const GoASTDeclStmt&) = delete;
    const GoASTDeclStmt& operator=(const GoASTDeclStmt&) = delete;
};

class GoASTDeferStmt : public GoASTStmt
{
public:
    explicit GoASTDeferStmt(GoASTCallExpr* call) : GoASTStmt(eDeferStmt), m_call(call) {}
    virtual ~GoASTDeferStmt() { }

    const char* GetKindName() const { return "DeferStmt"; }

    static bool
    classof(const GoASTNode* n) { return n->GetKind() == eDeferStmt; }
    
    const GoASTCallExpr* GetCall() const { return m_call.get(); }
    void SetCall(GoASTCallExpr* call) { m_call.reset(call); }

private:
    std::unique_ptr<GoASTCallExpr> m_call;

    GoASTDeferStmt(const GoASTDeferStmt&) = delete;
    const GoASTDeferStmt& operator=(const GoASTDeferStmt&) = delete;
};

class GoASTEllipsis : public GoASTExpr
{
public:
    explicit GoASTEllipsis(GoASTExpr* elt) : GoASTExpr(eEllipsis), m_elt(elt) {}
    virtual ~GoASTEllipsis() { }

    const char* GetKindName() const { return "Ellipsis"; }

    static bool
    classof(const GoASTNode* n) { return n->GetKind() == eEllipsis; }
    
    const GoASTExpr* GetElt() const { return m_elt.get(); }
    void SetElt(GoASTExpr* elt) { m_elt.reset(elt); }

private:
    std::unique_ptr<GoASTExpr> m_elt;

    GoASTEllipsis(const GoASTEllipsis&) = delete;
    const GoASTEllipsis& operator=(const GoASTEllipsis&) = delete;
};

class GoASTEmptyStmt : public GoASTStmt
{
public:
    GoASTEmptyStmt() : GoASTStmt(eEmptyStmt) {}
    virtual ~GoASTEmptyStmt() { }

    const char* GetKindName() const { return "EmptyStmt"; }

    static bool
    classof(const GoASTNode* n) { return n->GetKind() == eEmptyStmt; }
    
private:

    GoASTEmptyStmt(const GoASTEmptyStmt&) = delete;
    const GoASTEmptyStmt& operator=(const GoASTEmptyStmt&) = delete;
};

class GoASTExprStmt : public GoASTStmt
{
public:
    explicit GoASTExprStmt(GoASTExpr* x) : GoASTStmt(eExprStmt), m_x(x) {}
    virtual ~GoASTExprStmt() { }

    const char* GetKindName() const { return "ExprStmt"; }

    static bool
    classof(const GoASTNode* n) { return n->GetKind() == eExprStmt; }
    
    const GoASTExpr* GetX() const { return m_x.get(); }
    void SetX(GoASTExpr* x) { m_x.reset(x); }

private:
    std::unique_ptr<GoASTExpr> m_x;

    GoASTExprStmt(const GoASTExprStmt&) = delete;
    const GoASTExprStmt& operator=(const GoASTExprStmt&) = delete;
};

class GoASTField : public GoASTNode
{
public:
    GoASTField() : GoASTNode(eField) {}
    virtual ~GoASTField() { }

    const char* GetKindName() const { return "Field"; }

    static bool
    classof(const GoASTNode* n) { return n->GetKind() == eField; }
    
    size_t NumNames() const { return m_names.size(); }
    const GoASTIdent* GetNames(int i) const { return m_names[i].get(); }
    void AddNames(GoASTIdent* names) { m_names.push_back(std::unique_ptr<GoASTIdent>(names)); }

    const GoASTExpr* GetType() const { return m_type.get(); }
    void SetType(GoASTExpr* type) { m_type.reset(type); }

    const GoASTBasicLit* GetTag() const { return m_tag.get(); }
    void SetTag(GoASTBasicLit* tag) { m_tag.reset(tag); }

private:
    std::vector<std::unique_ptr<GoASTIdent> > m_names;
    std::unique_ptr<GoASTExpr> m_type;
    std::unique_ptr<GoASTBasicLit> m_tag;

    GoASTField(const GoASTField&) = delete;
    const GoASTField& operator=(const GoASTField&) = delete;
};

class GoASTFieldList : public GoASTNode
{
public:
    GoASTFieldList() : GoASTNode(eFieldList) {}
    virtual ~GoASTFieldList() { }

    const char* GetKindName() const { return "FieldList"; }

    static bool
    classof(const GoASTNode* n) { return n->GetKind() == eFieldList; }
    
    size_t NumList() const { return m_list.size(); }
    const GoASTField* GetList(int i) const { return m_list[i].get(); }
    void AddList(GoASTField* list) { m_list.push_back(std::unique_ptr<GoASTField>(list)); }

private:
    std::vector<std::unique_ptr<GoASTField> > m_list;

    GoASTFieldList(const GoASTFieldList&) = delete;
    const GoASTFieldList& operator=(const GoASTFieldList&) = delete;
};

class GoASTForStmt : public GoASTStmt
{
public:
    GoASTForStmt(GoASTStmt* init, GoASTExpr* cond, GoASTStmt* post, GoASTBlockStmt* body) : GoASTStmt(eForStmt), m_init(init), m_cond(cond), m_post(post), m_body(body) {}
    virtual ~GoASTForStmt() { }

    const char* GetKindName() const { return "ForStmt"; }

    static bool
    classof(const GoASTNode* n) { return n->GetKind() == eForStmt; }
    
    const GoASTStmt* GetInit() const { return m_init.get(); }
    void SetInit(GoASTStmt* init) { m_init.reset(init); }

    const GoASTExpr* GetCond() const { return m_cond.get(); }
    void SetCond(GoASTExpr* cond) { m_cond.reset(cond); }

    const GoASTStmt* GetPost() const { return m_post.get(); }
    void SetPost(GoASTStmt* post) { m_post.reset(post); }

    const GoASTBlockStmt* GetBody() const { return m_body.get(); }
    void SetBody(GoASTBlockStmt* body) { m_body.reset(body); }

private:
    std::unique_ptr<GoASTStmt> m_init;
    std::unique_ptr<GoASTExpr> m_cond;
    std::unique_ptr<GoASTStmt> m_post;
    std::unique_ptr<GoASTBlockStmt> m_body;

    GoASTForStmt(const GoASTForStmt&) = delete;
    const GoASTForStmt& operator=(const GoASTForStmt&) = delete;
};

class GoASTFuncType : public GoASTExpr
{
public:
    GoASTFuncType(GoASTFieldList* params, GoASTFieldList* results) : GoASTExpr(eFuncType), m_params(params), m_results(results) {}
    virtual ~GoASTFuncType() { }

    const char* GetKindName() const { return "FuncType"; }

    static bool
    classof(const GoASTNode* n) { return n->GetKind() == eFuncType; }
    
    const GoASTFieldList* GetParams() const { return m_params.get(); }
    void SetParams(GoASTFieldList* params) { m_params.reset(params); }

    const GoASTFieldList* GetResults() const { return m_results.get(); }
    void SetResults(GoASTFieldList* results) { m_results.reset(results); }

private:
    std::unique_ptr<GoASTFieldList> m_params;
    std::unique_ptr<GoASTFieldList> m_results;

    GoASTFuncType(const GoASTFuncType&) = delete;
    const GoASTFuncType& operator=(const GoASTFuncType&) = delete;
};

class GoASTFuncDecl : public GoASTDecl
{
public:
    GoASTFuncDecl(GoASTFieldList* recv, GoASTIdent* name, GoASTFuncType* type, GoASTBlockStmt* body) : GoASTDecl(eFuncDecl), m_recv(recv), m_name(name), m_type(type), m_body(body) {}
    virtual ~GoASTFuncDecl() { }

    const char* GetKindName() const { return "FuncDecl"; }

    static bool
    classof(const GoASTNode* n) { return n->GetKind() == eFuncDecl; }
    
    const GoASTFieldList* GetRecv() const { return m_recv.get(); }
    void SetRecv(GoASTFieldList* recv) { m_recv.reset(recv); }

    const GoASTIdent* GetName() const { return m_name.get(); }
    void SetName(GoASTIdent* name) { m_name.reset(name); }

    const GoASTFuncType* GetType() const { return m_type.get(); }
    void SetType(GoASTFuncType* type) { m_type.reset(type); }

    const GoASTBlockStmt* GetBody() const { return m_body.get(); }
    void SetBody(GoASTBlockStmt* body) { m_body.reset(body); }

private:
    std::unique_ptr<GoASTFieldList> m_recv;
    std::unique_ptr<GoASTIdent> m_name;
    std::unique_ptr<GoASTFuncType> m_type;
    std::unique_ptr<GoASTBlockStmt> m_body;

    GoASTFuncDecl(const GoASTFuncDecl&) = delete;
    const GoASTFuncDecl& operator=(const GoASTFuncDecl&) = delete;
};

class GoASTFuncLit : public GoASTExpr
{
public:
    GoASTFuncLit(GoASTFuncType* type, GoASTBlockStmt* body) : GoASTExpr(eFuncLit), m_type(type), m_body(body) {}
    virtual ~GoASTFuncLit() { }

    const char* GetKindName() const { return "FuncLit"; }

    static bool
    classof(const GoASTNode* n) { return n->GetKind() == eFuncLit; }
    
    const GoASTFuncType* GetType() const { return m_type.get(); }
    void SetType(GoASTFuncType* type) { m_type.reset(type); }

    const GoASTBlockStmt* GetBody() const { return m_body.get(); }
    void SetBody(GoASTBlockStmt* body) { m_body.reset(body); }

private:
    std::unique_ptr<GoASTFuncType> m_type;
    std::unique_ptr<GoASTBlockStmt> m_body;

    GoASTFuncLit(const GoASTFuncLit&) = delete;
    const GoASTFuncLit& operator=(const GoASTFuncLit&) = delete;
};

class GoASTGenDecl : public GoASTDecl
{
public:
    GoASTGenDecl() : GoASTDecl(eGenDecl) {}
    virtual ~GoASTGenDecl() { }

    const char* GetKindName() const { return "GenDecl"; }

    static bool
    classof(const GoASTNode* n) { return n->GetKind() == eGenDecl; }
    
    TokenType GetTok() const { return m_tok; }
    void SetTok(TokenType tok) { m_tok = tok; }

    size_t NumSpecs() const { return m_specs.size(); }
    const GoASTSpec* GetSpecs(int i) const { return m_specs[i].get(); }
    void AddSpecs(GoASTSpec* specs) { m_specs.push_back(std::unique_ptr<GoASTSpec>(specs)); }

private:
    TokenType m_tok;
    std::vector<std::unique_ptr<GoASTSpec> > m_specs;

    GoASTGenDecl(const GoASTGenDecl&) = delete;
    const GoASTGenDecl& operator=(const GoASTGenDecl&) = delete;
};

class GoASTGoStmt : public GoASTStmt
{
public:
    explicit GoASTGoStmt(GoASTCallExpr* call) : GoASTStmt(eGoStmt), m_call(call) {}
    virtual ~GoASTGoStmt() { }

    const char* GetKindName() const { return "GoStmt"; }

    static bool
    classof(const GoASTNode* n) { return n->GetKind() == eGoStmt; }
    
    const GoASTCallExpr* GetCall() const { return m_call.get(); }
    void SetCall(GoASTCallExpr* call) { m_call.reset(call); }

private:
    std::unique_ptr<GoASTCallExpr> m_call;

    GoASTGoStmt(const GoASTGoStmt&) = delete;
    const GoASTGoStmt& operator=(const GoASTGoStmt&) = delete;
};

class GoASTIfStmt : public GoASTStmt
{
public:
    GoASTIfStmt(GoASTStmt* init, GoASTExpr* cond, GoASTBlockStmt* body, GoASTStmt* els) : GoASTStmt(eIfStmt), m_init(init), m_cond(cond), m_body(body), m_els(els) {}
    virtual ~GoASTIfStmt() { }

    const char* GetKindName() const { return "IfStmt"; }

    static bool
    classof(const GoASTNode* n) { return n->GetKind() == eIfStmt; }
    
    const GoASTStmt* GetInit() const { return m_init.get(); }
    void SetInit(GoASTStmt* init) { m_init.reset(init); }

    const GoASTExpr* GetCond() const { return m_cond.get(); }
    void SetCond(GoASTExpr* cond) { m_cond.reset(cond); }

    const GoASTBlockStmt* GetBody() const { return m_body.get(); }
    void SetBody(GoASTBlockStmt* body) { m_body.reset(body); }

    const GoASTStmt* GetEls() const { return m_els.get(); }
    void SetEls(GoASTStmt* els) { m_els.reset(els); }

private:
    std::unique_ptr<GoASTStmt> m_init;
    std::unique_ptr<GoASTExpr> m_cond;
    std::unique_ptr<GoASTBlockStmt> m_body;
    std::unique_ptr<GoASTStmt> m_els;

    GoASTIfStmt(const GoASTIfStmt&) = delete;
    const GoASTIfStmt& operator=(const GoASTIfStmt&) = delete;
};

class GoASTImportSpec : public GoASTSpec
{
public:
    GoASTImportSpec(GoASTIdent* name, GoASTBasicLit* path) : GoASTSpec(eImportSpec), m_name(name), m_path(path) {}
    virtual ~GoASTImportSpec() { }

    const char* GetKindName() const { return "ImportSpec"; }

    static bool
    classof(const GoASTNode* n) { return n->GetKind() == eImportSpec; }
    
    const GoASTIdent* GetName() const { return m_name.get(); }
    void SetName(GoASTIdent* name) { m_name.reset(name); }

    const GoASTBasicLit* GetPath() const { return m_path.get(); }
    void SetPath(GoASTBasicLit* path) { m_path.reset(path); }

private:
    std::unique_ptr<GoASTIdent> m_name;
    std::unique_ptr<GoASTBasicLit> m_path;

    GoASTImportSpec(const GoASTImportSpec&) = delete;
    const GoASTImportSpec& operator=(const GoASTImportSpec&) = delete;
};

class GoASTIncDecStmt : public GoASTStmt
{
public:
    GoASTIncDecStmt(GoASTExpr* x, TokenType tok) : GoASTStmt(eIncDecStmt), m_x(x), m_tok(tok) {}
    virtual ~GoASTIncDecStmt() { }

    const char* GetKindName() const { return "IncDecStmt"; }

    static bool
    classof(const GoASTNode* n) { return n->GetKind() == eIncDecStmt; }
    
    const GoASTExpr* GetX() const { return m_x.get(); }
    void SetX(GoASTExpr* x) { m_x.reset(x); }

    TokenType GetTok() const { return m_tok; }
    void SetTok(TokenType tok) { m_tok = tok; }

private:
    std::unique_ptr<GoASTExpr> m_x;
    TokenType m_tok;

    GoASTIncDecStmt(const GoASTIncDecStmt&) = delete;
    const GoASTIncDecStmt& operator=(const GoASTIncDecStmt&) = delete;
};

class GoASTIndexExpr : public GoASTExpr
{
public:
    GoASTIndexExpr(GoASTExpr* x, GoASTExpr* index) : GoASTExpr(eIndexExpr), m_x(x), m_index(index) {}
    virtual ~GoASTIndexExpr() { }

    const char* GetKindName() const { return "IndexExpr"; }

    static bool
    classof(const GoASTNode* n) { return n->GetKind() == eIndexExpr; }
    
    const GoASTExpr* GetX() const { return m_x.get(); }
    void SetX(GoASTExpr* x) { m_x.reset(x); }

    const GoASTExpr* GetIndex() const { return m_index.get(); }
    void SetIndex(GoASTExpr* index) { m_index.reset(index); }

private:
    std::unique_ptr<GoASTExpr> m_x;
    std::unique_ptr<GoASTExpr> m_index;

    GoASTIndexExpr(const GoASTIndexExpr&) = delete;
    const GoASTIndexExpr& operator=(const GoASTIndexExpr&) = delete;
};

class GoASTInterfaceType : public GoASTExpr
{
public:
    explicit GoASTInterfaceType(GoASTFieldList* methods) : GoASTExpr(eInterfaceType), m_methods(methods) {}
    virtual ~GoASTInterfaceType() { }

    const char* GetKindName() const { return "InterfaceType"; }

    static bool
    classof(const GoASTNode* n) { return n->GetKind() == eInterfaceType; }
    
    const GoASTFieldList* GetMethods() const { return m_methods.get(); }
    void SetMethods(GoASTFieldList* methods) { m_methods.reset(methods); }

private:
    std::unique_ptr<GoASTFieldList> m_methods;

    GoASTInterfaceType(const GoASTInterfaceType&) = delete;
    const GoASTInterfaceType& operator=(const GoASTInterfaceType&) = delete;
};

class GoASTKeyValueExpr : public GoASTExpr
{
public:
    GoASTKeyValueExpr(GoASTExpr* key, GoASTExpr* value) : GoASTExpr(eKeyValueExpr), m_key(key), m_value(value) {}
    virtual ~GoASTKeyValueExpr() { }

    const char* GetKindName() const { return "KeyValueExpr"; }

    static bool
    classof(const GoASTNode* n) { return n->GetKind() == eKeyValueExpr; }
    
    const GoASTExpr* GetKey() const { return m_key.get(); }
    void SetKey(GoASTExpr* key) { m_key.reset(key); }

    const GoASTExpr* GetValue() const { return m_value.get(); }
    void SetValue(GoASTExpr* value) { m_value.reset(value); }

private:
    std::unique_ptr<GoASTExpr> m_key;
    std::unique_ptr<GoASTExpr> m_value;

    GoASTKeyValueExpr(const GoASTKeyValueExpr&) = delete;
    const GoASTKeyValueExpr& operator=(const GoASTKeyValueExpr&) = delete;
};

class GoASTLabeledStmt : public GoASTStmt
{
public:
    GoASTLabeledStmt(GoASTIdent* label, GoASTStmt* stmt) : GoASTStmt(eLabeledStmt), m_label(label), m_stmt(stmt) {}
    virtual ~GoASTLabeledStmt() { }

    const char* GetKindName() const { return "LabeledStmt"; }

    static bool
    classof(const GoASTNode* n) { return n->GetKind() == eLabeledStmt; }
    
    const GoASTIdent* GetLabel() const { return m_label.get(); }
    void SetLabel(GoASTIdent* label) { m_label.reset(label); }

    const GoASTStmt* GetStmt() const { return m_stmt.get(); }
    void SetStmt(GoASTStmt* stmt) { m_stmt.reset(stmt); }

private:
    std::unique_ptr<GoASTIdent> m_label;
    std::unique_ptr<GoASTStmt> m_stmt;

    GoASTLabeledStmt(const GoASTLabeledStmt&) = delete;
    const GoASTLabeledStmt& operator=(const GoASTLabeledStmt&) = delete;
};

class GoASTMapType : public GoASTExpr
{
public:
    GoASTMapType(GoASTExpr* key, GoASTExpr* value) : GoASTExpr(eMapType), m_key(key), m_value(value) {}
    virtual ~GoASTMapType() { }

    const char* GetKindName() const { return "MapType"; }

    static bool
    classof(const GoASTNode* n) { return n->GetKind() == eMapType; }
    
    const GoASTExpr* GetKey() const { return m_key.get(); }
    void SetKey(GoASTExpr* key) { m_key.reset(key); }

    const GoASTExpr* GetValue() const { return m_value.get(); }
    void SetValue(GoASTExpr* value) { m_value.reset(value); }

private:
    std::unique_ptr<GoASTExpr> m_key;
    std::unique_ptr<GoASTExpr> m_value;

    GoASTMapType(const GoASTMapType&) = delete;
    const GoASTMapType& operator=(const GoASTMapType&) = delete;
};

class GoASTParenExpr : public GoASTExpr
{
public:
    explicit GoASTParenExpr(GoASTExpr* x) : GoASTExpr(eParenExpr), m_x(x) {}
    virtual ~GoASTParenExpr() { }

    const char* GetKindName() const { return "ParenExpr"; }

    static bool
    classof(const GoASTNode* n) { return n->GetKind() == eParenExpr; }
    
    const GoASTExpr* GetX() const { return m_x.get(); }
    void SetX(GoASTExpr* x) { m_x.reset(x); }

private:
    std::unique_ptr<GoASTExpr> m_x;

    GoASTParenExpr(const GoASTParenExpr&) = delete;
    const GoASTParenExpr& operator=(const GoASTParenExpr&) = delete;
};

class GoASTRangeStmt : public GoASTStmt
{
public:
    GoASTRangeStmt(GoASTExpr* key, GoASTExpr* value, bool define, GoASTExpr* x, GoASTBlockStmt* body) : GoASTStmt(eRangeStmt), m_key(key), m_value(value), m_define(define), m_x(x), m_body(body) {}
    virtual ~GoASTRangeStmt() { }

    const char* GetKindName() const { return "RangeStmt"; }

    static bool
    classof(const GoASTNode* n) { return n->GetKind() == eRangeStmt; }
    
    const GoASTExpr* GetKey() const { return m_key.get(); }
    void SetKey(GoASTExpr* key) { m_key.reset(key); }

    const GoASTExpr* GetValue() const { return m_value.get(); }
    void SetValue(GoASTExpr* value) { m_value.reset(value); }

    bool GetDefine() const { return m_define; }
    void SetDefine(bool define) { m_define = define; }

    const GoASTExpr* GetX() const { return m_x.get(); }
    void SetX(GoASTExpr* x) { m_x.reset(x); }

    const GoASTBlockStmt* GetBody() const { return m_body.get(); }
    void SetBody(GoASTBlockStmt* body) { m_body.reset(body); }

private:
    std::unique_ptr<GoASTExpr> m_key;
    std::unique_ptr<GoASTExpr> m_value;
    bool m_define;
    std::unique_ptr<GoASTExpr> m_x;
    std::unique_ptr<GoASTBlockStmt> m_body;

    GoASTRangeStmt(const GoASTRangeStmt&) = delete;
    const GoASTRangeStmt& operator=(const GoASTRangeStmt&) = delete;
};

class GoASTReturnStmt : public GoASTStmt
{
public:
    GoASTReturnStmt() : GoASTStmt(eReturnStmt) {}
    virtual ~GoASTReturnStmt() { }

    const char* GetKindName() const { return "ReturnStmt"; }

    static bool
    classof(const GoASTNode* n) { return n->GetKind() == eReturnStmt; }
    
    size_t NumResults() const { return m_results.size(); }
    const GoASTExpr* GetResults(int i) const { return m_results[i].get(); }
    void AddResults(GoASTExpr* results) { m_results.push_back(std::unique_ptr<GoASTExpr>(results)); }

private:
    std::vector<std::unique_ptr<GoASTExpr> > m_results;

    GoASTReturnStmt(const GoASTReturnStmt&) = delete;
    const GoASTReturnStmt& operator=(const GoASTReturnStmt&) = delete;
};

class GoASTSelectStmt : public GoASTStmt
{
public:
    explicit GoASTSelectStmt(GoASTBlockStmt* body) : GoASTStmt(eSelectStmt), m_body(body) {}
    virtual ~GoASTSelectStmt() { }

    const char* GetKindName() const { return "SelectStmt"; }

    static bool
    classof(const GoASTNode* n) { return n->GetKind() == eSelectStmt; }
    
    const GoASTBlockStmt* GetBody() const { return m_body.get(); }
    void SetBody(GoASTBlockStmt* body) { m_body.reset(body); }

private:
    std::unique_ptr<GoASTBlockStmt> m_body;

    GoASTSelectStmt(const GoASTSelectStmt&) = delete;
    const GoASTSelectStmt& operator=(const GoASTSelectStmt&) = delete;
};

class GoASTSelectorExpr : public GoASTExpr
{
public:
    GoASTSelectorExpr(GoASTExpr* x, GoASTIdent* sel) : GoASTExpr(eSelectorExpr), m_x(x), m_sel(sel) {}
    virtual ~GoASTSelectorExpr() { }

    const char* GetKindName() const { return "SelectorExpr"; }

    static bool
    classof(const GoASTNode* n) { return n->GetKind() == eSelectorExpr; }
    
    const GoASTExpr* GetX() const { return m_x.get(); }
    void SetX(GoASTExpr* x) { m_x.reset(x); }

    const GoASTIdent* GetSel() const { return m_sel.get(); }
    void SetSel(GoASTIdent* sel) { m_sel.reset(sel); }

private:
    std::unique_ptr<GoASTExpr> m_x;
    std::unique_ptr<GoASTIdent> m_sel;

    GoASTSelectorExpr(const GoASTSelectorExpr&) = delete;
    const GoASTSelectorExpr& operator=(const GoASTSelectorExpr&) = delete;
};

class GoASTSendStmt : public GoASTStmt
{
public:
    GoASTSendStmt(GoASTExpr* chan, GoASTExpr* value) : GoASTStmt(eSendStmt), m_chan(chan), m_value(value) {}
    virtual ~GoASTSendStmt() { }

    const char* GetKindName() const { return "SendStmt"; }

    static bool
    classof(const GoASTNode* n) { return n->GetKind() == eSendStmt; }
    
    const GoASTExpr* GetChan() const { return m_chan.get(); }
    void SetChan(GoASTExpr* chan) { m_chan.reset(chan); }

    const GoASTExpr* GetValue() const { return m_value.get(); }
    void SetValue(GoASTExpr* value) { m_value.reset(value); }

private:
    std::unique_ptr<GoASTExpr> m_chan;
    std::unique_ptr<GoASTExpr> m_value;

    GoASTSendStmt(const GoASTSendStmt&) = delete;
    const GoASTSendStmt& operator=(const GoASTSendStmt&) = delete;
};

class GoASTSliceExpr : public GoASTExpr
{
public:
    GoASTSliceExpr(GoASTExpr* x, GoASTExpr* low, GoASTExpr* high, GoASTExpr* max, bool slice3) : GoASTExpr(eSliceExpr), m_x(x), m_low(low), m_high(high), m_max(max), m_slice3(slice3) {}
    virtual ~GoASTSliceExpr() { }

    const char* GetKindName() const { return "SliceExpr"; }

    static bool
    classof(const GoASTNode* n) { return n->GetKind() == eSliceExpr; }
    
    const GoASTExpr* GetX() const { return m_x.get(); }
    void SetX(GoASTExpr* x) { m_x.reset(x); }

    const GoASTExpr* GetLow() const { return m_low.get(); }
    void SetLow(GoASTExpr* low) { m_low.reset(low); }

    const GoASTExpr* GetHigh() const { return m_high.get(); }
    void SetHigh(GoASTExpr* high) { m_high.reset(high); }

    const GoASTExpr* GetMax() const { return m_max.get(); }
    void SetMax(GoASTExpr* max) { m_max.reset(max); }

    bool GetSlice3() const { return m_slice3; }
    void SetSlice3(bool slice3) { m_slice3 = slice3; }

private:
    std::unique_ptr<GoASTExpr> m_x;
    std::unique_ptr<GoASTExpr> m_low;
    std::unique_ptr<GoASTExpr> m_high;
    std::unique_ptr<GoASTExpr> m_max;
    bool m_slice3;

    GoASTSliceExpr(const GoASTSliceExpr&) = delete;
    const GoASTSliceExpr& operator=(const GoASTSliceExpr&) = delete;
};

class GoASTStarExpr : public GoASTExpr
{
public:
    explicit GoASTStarExpr(GoASTExpr* x) : GoASTExpr(eStarExpr), m_x(x) {}
    virtual ~GoASTStarExpr() { }

    const char* GetKindName() const { return "StarExpr"; }

    static bool
    classof(const GoASTNode* n) { return n->GetKind() == eStarExpr; }
    
    const GoASTExpr* GetX() const { return m_x.get(); }
    void SetX(GoASTExpr* x) { m_x.reset(x); }

private:
    std::unique_ptr<GoASTExpr> m_x;

    GoASTStarExpr(const GoASTStarExpr&) = delete;
    const GoASTStarExpr& operator=(const GoASTStarExpr&) = delete;
};

class GoASTStructType : public GoASTExpr
{
public:
    explicit GoASTStructType(GoASTFieldList* fields) : GoASTExpr(eStructType), m_fields(fields) {}
    virtual ~GoASTStructType() { }

    const char* GetKindName() const { return "StructType"; }

    static bool
    classof(const GoASTNode* n) { return n->GetKind() == eStructType; }
    
    const GoASTFieldList* GetFields() const { return m_fields.get(); }
    void SetFields(GoASTFieldList* fields) { m_fields.reset(fields); }

private:
    std::unique_ptr<GoASTFieldList> m_fields;

    GoASTStructType(const GoASTStructType&) = delete;
    const GoASTStructType& operator=(const GoASTStructType&) = delete;
};

class GoASTSwitchStmt : public GoASTStmt
{
public:
    GoASTSwitchStmt(GoASTStmt* init, GoASTExpr* tag, GoASTBlockStmt* body) : GoASTStmt(eSwitchStmt), m_init(init), m_tag(tag), m_body(body) {}
    virtual ~GoASTSwitchStmt() { }

    const char* GetKindName() const { return "SwitchStmt"; }

    static bool
    classof(const GoASTNode* n) { return n->GetKind() == eSwitchStmt; }
    
    const GoASTStmt* GetInit() const { return m_init.get(); }
    void SetInit(GoASTStmt* init) { m_init.reset(init); }

    const GoASTExpr* GetTag() const { return m_tag.get(); }
    void SetTag(GoASTExpr* tag) { m_tag.reset(tag); }

    const GoASTBlockStmt* GetBody() const { return m_body.get(); }
    void SetBody(GoASTBlockStmt* body) { m_body.reset(body); }

private:
    std::unique_ptr<GoASTStmt> m_init;
    std::unique_ptr<GoASTExpr> m_tag;
    std::unique_ptr<GoASTBlockStmt> m_body;

    GoASTSwitchStmt(const GoASTSwitchStmt&) = delete;
    const GoASTSwitchStmt& operator=(const GoASTSwitchStmt&) = delete;
};

class GoASTTypeAssertExpr : public GoASTExpr
{
public:
    GoASTTypeAssertExpr(GoASTExpr* x, GoASTExpr* type) : GoASTExpr(eTypeAssertExpr), m_x(x), m_type(type) {}
    virtual ~GoASTTypeAssertExpr() { }

    const char* GetKindName() const { return "TypeAssertExpr"; }

    static bool
    classof(const GoASTNode* n) { return n->GetKind() == eTypeAssertExpr; }
    
    const GoASTExpr* GetX() const { return m_x.get(); }
    void SetX(GoASTExpr* x) { m_x.reset(x); }

    const GoASTExpr* GetType() const { return m_type.get(); }
    void SetType(GoASTExpr* type) { m_type.reset(type); }

private:
    std::unique_ptr<GoASTExpr> m_x;
    std::unique_ptr<GoASTExpr> m_type;

    GoASTTypeAssertExpr(const GoASTTypeAssertExpr&) = delete;
    const GoASTTypeAssertExpr& operator=(const GoASTTypeAssertExpr&) = delete;
};

class GoASTTypeSpec : public GoASTSpec
{
public:
    GoASTTypeSpec(GoASTIdent* name, GoASTExpr* type) : GoASTSpec(eTypeSpec), m_name(name), m_type(type) {}
    virtual ~GoASTTypeSpec() { }

    const char* GetKindName() const { return "TypeSpec"; }

    static bool
    classof(const GoASTNode* n) { return n->GetKind() == eTypeSpec; }
    
    const GoASTIdent* GetName() const { return m_name.get(); }
    void SetName(GoASTIdent* name) { m_name.reset(name); }

    const GoASTExpr* GetType() const { return m_type.get(); }
    void SetType(GoASTExpr* type) { m_type.reset(type); }

private:
    std::unique_ptr<GoASTIdent> m_name;
    std::unique_ptr<GoASTExpr> m_type;

    GoASTTypeSpec(const GoASTTypeSpec&) = delete;
    const GoASTTypeSpec& operator=(const GoASTTypeSpec&) = delete;
};

class GoASTTypeSwitchStmt : public GoASTStmt
{
public:
    GoASTTypeSwitchStmt(GoASTStmt* init, GoASTStmt* assign, GoASTBlockStmt* body) : GoASTStmt(eTypeSwitchStmt), m_init(init), m_assign(assign), m_body(body) {}
    virtual ~GoASTTypeSwitchStmt() { }

    const char* GetKindName() const { return "TypeSwitchStmt"; }

    static bool
    classof(const GoASTNode* n) { return n->GetKind() == eTypeSwitchStmt; }
    
    const GoASTStmt* GetInit() const { return m_init.get(); }
    void SetInit(GoASTStmt* init) { m_init.reset(init); }

    const GoASTStmt* GetAssign() const { return m_assign.get(); }
    void SetAssign(GoASTStmt* assign) { m_assign.reset(assign); }

    const GoASTBlockStmt* GetBody() const { return m_body.get(); }
    void SetBody(GoASTBlockStmt* body) { m_body.reset(body); }

private:
    std::unique_ptr<GoASTStmt> m_init;
    std::unique_ptr<GoASTStmt> m_assign;
    std::unique_ptr<GoASTBlockStmt> m_body;

    GoASTTypeSwitchStmt(const GoASTTypeSwitchStmt&) = delete;
    const GoASTTypeSwitchStmt& operator=(const GoASTTypeSwitchStmt&) = delete;
};

class GoASTUnaryExpr : public GoASTExpr
{
public:
    GoASTUnaryExpr(TokenType op, GoASTExpr* x) : GoASTExpr(eUnaryExpr), m_op(op), m_x(x) {}
    virtual ~GoASTUnaryExpr() { }

    const char* GetKindName() const { return "UnaryExpr"; }

    static bool
    classof(const GoASTNode* n) { return n->GetKind() == eUnaryExpr; }
    
    TokenType GetOp() const { return m_op; }
    void SetOp(TokenType op) { m_op = op; }

    const GoASTExpr* GetX() const { return m_x.get(); }
    void SetX(GoASTExpr* x) { m_x.reset(x); }

private:
    TokenType m_op;
    std::unique_ptr<GoASTExpr> m_x;

    GoASTUnaryExpr(const GoASTUnaryExpr&) = delete;
    const GoASTUnaryExpr& operator=(const GoASTUnaryExpr&) = delete;
};

class GoASTValueSpec : public GoASTSpec
{
public:
    GoASTValueSpec() : GoASTSpec(eValueSpec) {}
    virtual ~GoASTValueSpec() { }

    const char* GetKindName() const { return "ValueSpec"; }

    static bool
    classof(const GoASTNode* n) { return n->GetKind() == eValueSpec; }
    
    size_t NumNames() const { return m_names.size(); }
    const GoASTIdent* GetNames(int i) const { return m_names[i].get(); }
    void AddNames(GoASTIdent* names) { m_names.push_back(std::unique_ptr<GoASTIdent>(names)); }

    const GoASTExpr* GetType() const { return m_type.get(); }
    void SetType(GoASTExpr* type) { m_type.reset(type); }

    size_t NumValues() const { return m_values.size(); }
    const GoASTExpr* GetValues(int i) const { return m_values[i].get(); }
    void AddValues(GoASTExpr* values) { m_values.push_back(std::unique_ptr<GoASTExpr>(values)); }

private:
    std::vector<std::unique_ptr<GoASTIdent> > m_names;
    std::unique_ptr<GoASTExpr> m_type;
    std::vector<std::unique_ptr<GoASTExpr> > m_values;

    GoASTValueSpec(const GoASTValueSpec&) = delete;
    const GoASTValueSpec& operator=(const GoASTValueSpec&) = delete;
};


template <typename R, typename V>
R GoASTDecl::Visit(V* v) const
{
    switch(GetKind())
    {
    case eBadDecl:
        return v->VisitBadDecl(llvm::cast<const GoASTBadDecl*>(this));
    case eFuncDecl:
        return v->VisitFuncDecl(llvm::cast<const GoASTFuncDecl*>(this));
    case eGenDecl:
        return v->VisitGenDecl(llvm::cast<const GoASTGenDecl*>(this));
    default:
        assert(false && "Invalid kind");
    }
}

template <typename R, typename V>
R GoASTExpr::Visit(V* v) const
{
    switch(GetKind())
    {
    case eArrayType:
        return v->VisitArrayType(llvm::cast<const GoASTArrayType*>(this));
    case eBadExpr:
        return v->VisitBadExpr(llvm::cast<const GoASTBadExpr*>(this));
    case eBasicLit:
        return v->VisitBasicLit(llvm::cast<const GoASTBasicLit*>(this));
    case eBinaryExpr:
        return v->VisitBinaryExpr(llvm::cast<const GoASTBinaryExpr*>(this));
    case eIdent:
        return v->VisitIdent(llvm::cast<const GoASTIdent*>(this));
    case eCallExpr:
        return v->VisitCallExpr(llvm::cast<const GoASTCallExpr*>(this));
    case eChanType:
        return v->VisitChanType(llvm::cast<const GoASTChanType*>(this));
    case eCompositeLit:
        return v->VisitCompositeLit(llvm::cast<const GoASTCompositeLit*>(this));
    case eEllipsis:
        return v->VisitEllipsis(llvm::cast<const GoASTEllipsis*>(this));
    case eFuncType:
        return v->VisitFuncType(llvm::cast<const GoASTFuncType*>(this));
    case eFuncLit:
        return v->VisitFuncLit(llvm::cast<const GoASTFuncLit*>(this));
    case eIndexExpr:
        return v->VisitIndexExpr(llvm::cast<const GoASTIndexExpr*>(this));
    case eInterfaceType:
        return v->VisitInterfaceType(llvm::cast<const GoASTInterfaceType*>(this));
    case eKeyValueExpr:
        return v->VisitKeyValueExpr(llvm::cast<const GoASTKeyValueExpr*>(this));
    case eMapType:
        return v->VisitMapType(llvm::cast<const GoASTMapType*>(this));
    case eParenExpr:
        return v->VisitParenExpr(llvm::cast<const GoASTParenExpr*>(this));
    case eSelectorExpr:
        return v->VisitSelectorExpr(llvm::cast<const GoASTSelectorExpr*>(this));
    case eSliceExpr:
        return v->VisitSliceExpr(llvm::cast<const GoASTSliceExpr*>(this));
    case eStarExpr:
        return v->VisitStarExpr(llvm::cast<const GoASTStarExpr*>(this));
    case eStructType:
        return v->VisitStructType(llvm::cast<const GoASTStructType*>(this));
    case eTypeAssertExpr:
        return v->VisitTypeAssertExpr(llvm::cast<const GoASTTypeAssertExpr*>(this));
    case eUnaryExpr:
        return v->VisitUnaryExpr(llvm::cast<const GoASTUnaryExpr*>(this));
    default:
        assert(false && "Invalid kind");
    }
}

template <typename R, typename V>
R GoASTSpec::Visit(V* v) const
{
    switch(GetKind())
    {
    case eImportSpec:
        return v->VisitImportSpec(llvm::cast<const GoASTImportSpec*>(this));
    case eTypeSpec:
        return v->VisitTypeSpec(llvm::cast<const GoASTTypeSpec*>(this));
    case eValueSpec:
        return v->VisitValueSpec(llvm::cast<const GoASTValueSpec*>(this));
    default:
        assert(false && "Invalid kind");
    }
}

template <typename R, typename V>
R GoASTStmt::Visit(V* v) const
{
    switch(GetKind())
    {
    case eAssignStmt:
        return v->VisitAssignStmt(llvm::cast<const GoASTAssignStmt*>(this));
    case eBadStmt:
        return v->VisitBadStmt(llvm::cast<const GoASTBadStmt*>(this));
    case eBlockStmt:
        return v->VisitBlockStmt(llvm::cast<const GoASTBlockStmt*>(this));
    case eBranchStmt:
        return v->VisitBranchStmt(llvm::cast<const GoASTBranchStmt*>(this));
    case eCaseClause:
        return v->VisitCaseClause(llvm::cast<const GoASTCaseClause*>(this));
    case eCommClause:
        return v->VisitCommClause(llvm::cast<const GoASTCommClause*>(this));
    case eDeclStmt:
        return v->VisitDeclStmt(llvm::cast<const GoASTDeclStmt*>(this));
    case eDeferStmt:
        return v->VisitDeferStmt(llvm::cast<const GoASTDeferStmt*>(this));
    case eEmptyStmt:
        return v->VisitEmptyStmt(llvm::cast<const GoASTEmptyStmt*>(this));
    case eExprStmt:
        return v->VisitExprStmt(llvm::cast<const GoASTExprStmt*>(this));
    case eForStmt:
        return v->VisitForStmt(llvm::cast<const GoASTForStmt*>(this));
    case eGoStmt:
        return v->VisitGoStmt(llvm::cast<const GoASTGoStmt*>(this));
    case eIfStmt:
        return v->VisitIfStmt(llvm::cast<const GoASTIfStmt*>(this));
    case eIncDecStmt:
        return v->VisitIncDecStmt(llvm::cast<const GoASTIncDecStmt*>(this));
    case eLabeledStmt:
        return v->VisitLabeledStmt(llvm::cast<const GoASTLabeledStmt*>(this));
    case eRangeStmt:
        return v->VisitRangeStmt(llvm::cast<const GoASTRangeStmt*>(this));
    case eReturnStmt:
        return v->VisitReturnStmt(llvm::cast<const GoASTReturnStmt*>(this));
    case eSelectStmt:
        return v->VisitSelectStmt(llvm::cast<const GoASTSelectStmt*>(this));
    case eSendStmt:
        return v->VisitSendStmt(llvm::cast<const GoASTSendStmt*>(this));
    case eSwitchStmt:
        return v->VisitSwitchStmt(llvm::cast<const GoASTSwitchStmt*>(this));
    case eTypeSwitchStmt:
        return v->VisitTypeSwitchStmt(llvm::cast<const GoASTTypeSwitchStmt*>(this));
    default:
        assert(false && "Invalid kind");
    }
}

}  // namespace lldb_private

#endif

